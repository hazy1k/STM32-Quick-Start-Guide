# 第八章 高级定时器介绍及应用

## 1. 高级定时简介

高级定时器的框图和通用定时器框图很类似，只是添加了其它的一些功能，如：重复计数器、带死区控制的互补输出通道、断路输入等。这些功能在高级定时器框图的位置如下：

![屏幕截图 2025-07-15 153841.png](https://raw.githubusercontent.com/hazy1k/My-drawing-bed/main/2025/07/15-15-38-47-屏幕截图%202025-07-15%20153841.png)

上图中，框出来三个部分，这是和通用定时器不同的地方，下面来分别介绍它们。

### 1.1 重复计数器

在 F4 系列中，高级定时器 TIM1 和 TIM8 都有重复计数器。下面来介绍一下重复计数器有什么作用？在学习基本定时器和通用定时器的时候，我们知道定时器发生上溢或者下溢时，会直接生成更新事件。但是有重复计数器的定时器并不完全是这样的，定时器每次发生上溢或下溢时，重复计数器的值会减一，当重复计数器的值为 0 时，再发生一次上溢或者下溢才会生成定时器更新事件。如果我们设置重复计数器寄存器 RCR 的值为 N，那么更新事件将在定时器发生 N+1 次上溢或下溢时发生。

这里需要注意的是重复计数器寄存器是具有影子寄存器的，所以 RCR 寄存器只是起缓冲的作用。 RCR 寄存器的值会在更新事件发生时，被转移至其影子寄存器中，从而真正生效。

重复计数器的特性，在控制生成 PWM 信号时很有用，后面会有相应的实验。

### 1.2 输出比较

高级定时器输出比较部分和通用定时器相比，多了带死区控制的互补输出功能。

IMx_CH1N、 TIMx_CH2N 和 TIMx_CH3N 分别是定时器通道 1、通道 2 和通道 3的互补输出通道，通道 4 是没有互补输出通道的。 DTG 是死区发生器，死区时间由 DTG[7:0]位来配置。 如果不使用互补通道和死区时间控制，那么高级定时器 TIM1 和 TIM8 和通用定时器的输出比较部分使用方法基本一样，只是要注意 MOE 位得置 1 定时器才能输出。

如果使用互补通道，那么就有一定的区别了，具体我们在高级定时器互补输出带死区控制实验小节再来介绍

### 1.3 断路功能

断路功能也称刹车功能，一般用于电机控制的刹车。 F4 系列有一个断路通道，断路源可以是刹车输入引脚（TIMx_BKIN），也可以是一个时钟失败事件。时钟失败事件由复位时钟控制器中的时钟安全系统产生。系统复位后，断路功能默认被禁止， MOE 位为低。

使能断路功能的方法：将 TIMx_BDTR 的位 BKE 置 1。断路输入引脚 TIMx_BKIN 的输入有效电平可通过 TIMx_BDTR 寄存器的位 BKP 设置。

使能刹车功能后：由 TIMx_BDTR 的 MOE、 OSSI、 OSSR 位， TIMx_CR2 的 OISx、 OISxN位， TIMx_CCER 的 CCxE、 CCxNE 位控制 OCx 和 OCxN 输出状态。无论何时， OCx 和 OCxN输出都不能同时处在有效电平。

当发生断路输入后，会怎么样？

1. MOE 位被异步地清零， OCx 和 OCxN 为无效、空闲或复位状态(由 OSSI 位选择)。

2. OCx 和 OCxN 的状态：由相关控制位状态决定，当使用互补输出时：根据情况自动控制输出电平，参考《STM32F4xx 参考手册_V4(中文版).pdf》手册第 382 页的表 73 具有断路功能的互补通道 Ocx 和 OcxN 的控制位。

3. BIF 位置 1，如果使能了 BIE 位，还会产生刹车中断；如果使能了 TDE 位，会产生 DMA请求。

4. 如果 AOE 位置 1，在下一个更新事件 UEV 时， MOE 位被自动置 1。

## 2. 高级定时器使用示例

### 2.1 输出指定个数PWM

要实现定时器输出指定个数 PWM，只需要掌握下面几点内容：

第一，如果大家还不清楚定时器是如何输出 PWM 的，请回顾通用定时器 PWM 输出实验的内容，这部分的知识是一样的。但是需要注意的是：我们需要把 MOE 位置 1，这样高级定时器的通道才能输出。

第二，要清楚重复计数器特性，设置重复计数器寄存器 RCR 的值为 N，那么更新事件将在定时器发生 N+1 次上溢或下溢时发生。换句话来说就是，想要指定输出 N 个 PWM，只需要把N-1 写入 RCR 寄存器。因为在边沿对齐模式下，定时器溢出周期对应着 PWM 周期，我们只要在更新事件发生时，停止输出 PWM 就行。

第三，为了保证定时器输出指定个数的 PWM 后，定时器马上停止继续输出，我们使能更新中断，并在定时器中断里关闭计数器。

#### 2.1.1 TIM8相关参数宏定义

```c
#ifndef __ATIM_H
#define __ATIM_H

#include <sys.h>

/* 使用TIM8通道1输出PWM */
#define PWM_TIMER               TIM8
#define PWM_CHANNEL            TIM_CHANNEL_1
#define PWM_GPIO_PORT          GPIOC
#define PWM_GPIO_PIN           GPIO_PIN_6
#define PWM_GPIO_AF            GPIO_AF3_TIM8
#define PWM_IRQn               TIM8_UP_TIM13_IRQn
#define PWM_IRQHandler         TIM8_UP_TIM13_IRQHandler

/* 函数声明 */
void tim8_pwm_init(uint16_t arr, uint16_t psc);
void tim8_set_pulse_count(uint32_t count);

#endif /* __ATIM_H */

```

#### 2.1.2 PWM初始化

```c
/* PWM初始化 */
void tim8_pwm_init(uint16_t arr, uint16_t psc) {
    GPIO_InitTypeDef gpio_init = {0};
    TIM_OC_InitTypeDef oc_init = {0};
    
    /* 1. 使能时钟 */
    __HAL_RCC_GPIOC_CLK_ENABLE();
    __HAL_RCC_TIM8_CLK_ENABLE();
    
    /* 2. 配置GPIO */
    gpio_init.Pin = PWM_GPIO_PIN;
    gpio_init.Mode = GPIO_MODE_AF_PP;
    gpio_init.Pull = GPIO_PULLUP;
    gpio_init.Speed = GPIO_SPEED_FREQ_HIGH;
    gpio_init.Alternate = PWM_GPIO_AF;
    HAL_GPIO_Init(PWM_GPIO_PORT, &gpio_init);
    
    /* 3. 配置定时器 */
    tim8_handle.Instance = PWM_TIMER;
    tim8_handle.Init.Prescaler = psc;
    tim8_handle.Init.CounterMode = TIM_COUNTERMODE_UP;
    tim8_handle.Init.Period = arr;
    tim8_handle.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
    tim8_handle.Init.RepetitionCounter = 0;
    HAL_TIM_PWM_Init(&tim8_handle);
    
    /* 4. 配置PWM通道 */
    oc_init.OCMode = TIM_OCMODE_PWM1;
    oc_init.Pulse = arr / 2;  // 默认50%占空比
    oc_init.OCPolarity = TIM_OCPOLARITY_HIGH;
    HAL_TIM_PWM_ConfigChannel(&tim8_handle, &oc_init, PWM_CHANNEL);
    
    /* 5. 配置中断 */
    HAL_NVIC_SetPriority(PWM_IRQn, 1, 3);
    HAL_NVIC_EnableIRQ(PWM_IRQn);
    __HAL_TIM_ENABLE_IT(&tim8_handle, TIM_IT_UPDATE);
    
    /* 6. 启动PWM */
    HAL_TIM_PWM_Start(&tim8_handle, PWM_CHANNEL);
}
```

#### 2.1.3 设置脉冲数

```c

void tim8_set_pulse_count(uint32_t count) {
    if (count == 0) return;
    
    pulse_remain = count;
    HAL_TIM_GenerateEvent(&tim8_handle, TIM_EVENTSOURCE_UPDATE);
    __HAL_TIM_ENABLE(&tim8_handle);
}
```

#### 2.1.4 TIM中断处理函数

```c
/* 定时器中断处理 */
void PWM_IRQHandler(void) {
    if (__HAL_TIM_GET_FLAG(&tim8_handle, TIM_FLAG_UPDATE)) {
        uint16_t pulses = 0;
        
        if (pulse_remain > 0) {
            pulses = (pulse_remain > 256) ? 256 : pulse_remain;
            pulse_remain -= pulses;
            
            PWM_TIMER->RCR = pulses - 1;  // 设置重复计数器
            HAL_TIM_GenerateEvent(&tim8_handle, TIM_EVENTSOURCE_UPDATE);
            __HAL_TIM_ENABLE(&tim8_handle);
        } else {
            PWM_TIMER->CR1 &= ~TIM_CR1_CEN;  // 关闭定时器
        }
        
        __HAL_TIM_CLEAR_IT(&tim8_handle, TIM_IT_UPDATE);
    }
}
```

#### 2.1.4 主函数测试

```c
#include <bsp_init.h>
#include <atim.h>
#include <stdio.h>

int main(void) {
    uint8_t key_value = 0;
    uint8_t i = 0;
    GPIO_InitTypeDef GPIO_InitStructure;
    bsp_init();
    GPIO_InitStructure.Pin = LED1_GPIO_Pin;
    GPIO_InitStructure.Mode = GPIO_MODE_INPUT;
    GPIO_InitStructure.Pull = GPIO_PULLUP;
    HAL_GPIO_Init(LED_GPIO_Port, &GPIO_InitStructure);
    tim8_pwm_init(10000-1, 8400-1);
    TIM8->CCR1 = 5000; // 占空比为50%
    tim8_set_pulse_count(5); // 设置脉冲数为5
    while(1)
    {
        key_value = key_scan(0);
        if(key_value == KEY0_Press)
        {
            tim8_set_pulse_count(10); // 设置脉冲数为10
        }
        i++;
        delay_ms(10);
        if(i>50)
        {
            i=0;
            LED_TOGGLE(LED0_GPIO_Pin);
        }
    }
}

```

### 2.2 输出比较模式

### 2.3 互补输出带死区控制

### 2.4 PWM输入模式
