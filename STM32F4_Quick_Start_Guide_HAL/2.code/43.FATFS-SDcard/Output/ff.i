# 1 "../Middlewares/FATFS/source/ff.c"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 387 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "../Middlewares/FATFS/source/ff.c" 2
# 22 "../Middlewares/FATFS/source/ff.c"
# 1 "E:\\dianzi\\MDKv5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 1 3
# 51 "E:\\dianzi\\MDKv5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
    typedef unsigned int size_t;






extern __attribute__((__nothrow__)) void *memcpy(void * __restrict ,
                    const void * __restrict , size_t ) __attribute__((__nonnull__(1,2)));






extern __attribute__((__nothrow__)) void *memmove(void * ,
                    const void * , size_t ) __attribute__((__nonnull__(1,2)));
# 77 "E:\\dianzi\\MDKv5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) char *strcpy(char * __restrict , const char * __restrict ) __attribute__((__nonnull__(1,2)));






extern __attribute__((__nothrow__)) char *strncpy(char * __restrict , const char * __restrict , size_t ) __attribute__((__nonnull__(1,2)));
# 93 "E:\\dianzi\\MDKv5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) char *strcat(char * __restrict , const char * __restrict ) __attribute__((__nonnull__(1,2)));






extern __attribute__((__nothrow__)) char *strncat(char * __restrict , const char * __restrict , size_t ) __attribute__((__nonnull__(1,2)));
# 117 "E:\\dianzi\\MDKv5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) int memcmp(const void * , const void * , size_t ) __attribute__((__nonnull__(1,2)));







extern __attribute__((__nothrow__)) int strcmp(const char * , const char * ) __attribute__((__nonnull__(1,2)));






extern __attribute__((__nothrow__)) int strncmp(const char * , const char * , size_t ) __attribute__((__nonnull__(1,2)));
# 141 "E:\\dianzi\\MDKv5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) int strcasecmp(const char * , const char * ) __attribute__((__nonnull__(1,2)));







extern __attribute__((__nothrow__)) int strncasecmp(const char * , const char * , size_t ) __attribute__((__nonnull__(1,2)));
# 158 "E:\\dianzi\\MDKv5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) int strcoll(const char * , const char * ) __attribute__((__nonnull__(1,2)));
# 169 "E:\\dianzi\\MDKv5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) size_t strxfrm(char * __restrict , const char * __restrict , size_t ) __attribute__((__nonnull__(2)));
# 193 "E:\\dianzi\\MDKv5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) void *memchr(const void * , int , size_t ) __attribute__((__nonnull__(1)));
# 209 "E:\\dianzi\\MDKv5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) char *strchr(const char * , int ) __attribute__((__nonnull__(1)));
# 218 "E:\\dianzi\\MDKv5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) size_t strcspn(const char * , const char * ) __attribute__((__nonnull__(1,2)));
# 232 "E:\\dianzi\\MDKv5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) char *strpbrk(const char * , const char * ) __attribute__((__nonnull__(1,2)));
# 247 "E:\\dianzi\\MDKv5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) char *strrchr(const char * , int ) __attribute__((__nonnull__(1)));
# 257 "E:\\dianzi\\MDKv5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) size_t strspn(const char * , const char * ) __attribute__((__nonnull__(1,2)));
# 270 "E:\\dianzi\\MDKv5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) char *strstr(const char * , const char * ) __attribute__((__nonnull__(1,2)));
# 280 "E:\\dianzi\\MDKv5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) char *strtok(char * __restrict , const char * __restrict ) __attribute__((__nonnull__(2)));
extern __attribute__((__nothrow__)) char *_strtok_r(char * , const char * , char ** ) __attribute__((__nonnull__(2,3)));
# 321 "E:\\dianzi\\MDKv5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) void *memset(void * , int , size_t ) __attribute__((__nonnull__(1)));





extern __attribute__((__nothrow__)) char *strerror(int );







extern __attribute__((__nothrow__)) size_t strlen(const char * ) __attribute__((__nonnull__(1)));






extern __attribute__((__nothrow__)) size_t strlcpy(char * , const char * , size_t ) __attribute__((__nonnull__(1,2)));
# 362 "E:\\dianzi\\MDKv5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) size_t strlcat(char * , const char * , size_t ) __attribute__((__nonnull__(1,2)));
# 388 "E:\\dianzi\\MDKv5\\ARM\\ARMCLANG\\Bin\\..\\include\\string.h" 3
extern __attribute__((__nothrow__)) void _membitcpybl(void * , const void * , int , int , size_t ) __attribute__((__nonnull__(1,2)));
extern __attribute__((__nothrow__)) void _membitcpybb(void * , const void * , int , int , size_t ) __attribute__((__nonnull__(1,2)));
extern __attribute__((__nothrow__)) void _membitcpyhl(void * , const void * , int , int , size_t ) __attribute__((__nonnull__(1,2)));
extern __attribute__((__nothrow__)) void _membitcpyhb(void * , const void * , int , int , size_t ) __attribute__((__nonnull__(1,2)));
extern __attribute__((__nothrow__)) void _membitcpywl(void * , const void * , int , int , size_t ) __attribute__((__nonnull__(1,2)));
extern __attribute__((__nothrow__)) void _membitcpywb(void * , const void * , int , int , size_t ) __attribute__((__nonnull__(1,2)));
extern __attribute__((__nothrow__)) void _membitmovebl(void * , const void * , int , int , size_t ) __attribute__((__nonnull__(1,2)));
extern __attribute__((__nothrow__)) void _membitmovebb(void * , const void * , int , int , size_t ) __attribute__((__nonnull__(1,2)));
extern __attribute__((__nothrow__)) void _membitmovehl(void * , const void * , int , int , size_t ) __attribute__((__nonnull__(1,2)));
extern __attribute__((__nothrow__)) void _membitmovehb(void * , const void * , int , int , size_t ) __attribute__((__nonnull__(1,2)));
extern __attribute__((__nothrow__)) void _membitmovewl(void * , const void * , int , int , size_t ) __attribute__((__nonnull__(1,2)));
extern __attribute__((__nothrow__)) void _membitmovewb(void * , const void * , int , int , size_t ) __attribute__((__nonnull__(1,2)));
# 23 "../Middlewares/FATFS/source/ff.c" 2
# 1 "../Middlewares/FATFS/source/ff.h" 1
# 29 "../Middlewares/FATFS/source/ff.h"
# 1 "../Middlewares/FATFS/source/ffconf.h" 1
# 30 "../Middlewares/FATFS/source/ff.h" 2
# 48 "../Middlewares/FATFS/source/ff.h"
# 1 "E:\\dianzi\\MDKv5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdint.h" 1 3
# 56 "E:\\dianzi\\MDKv5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdint.h" 3
typedef signed char int8_t;
typedef signed short int int16_t;
typedef signed int int32_t;
typedef signed long long int int64_t;


typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long long int uint64_t;





typedef signed char int_least8_t;
typedef signed short int int_least16_t;
typedef signed int int_least32_t;
typedef signed long long int int_least64_t;


typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;
typedef unsigned long long int uint_least64_t;




typedef signed int int_fast8_t;
typedef signed int int_fast16_t;
typedef signed int int_fast32_t;
typedef signed long long int int_fast64_t;


typedef unsigned int uint_fast8_t;
typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
typedef unsigned long long int uint_fast64_t;






typedef signed int intptr_t;
typedef unsigned int uintptr_t;



typedef signed long long intmax_t;
typedef unsigned long long uintmax_t;
# 49 "../Middlewares/FATFS/source/ff.h" 2
typedef unsigned int UINT;
typedef unsigned char BYTE;
typedef uint16_t WORD;
typedef uint32_t DWORD;
typedef uint64_t QWORD;
typedef WORD WCHAR;
# 72 "../Middlewares/FATFS/source/ff.h"
typedef QWORD FSIZE_t;



typedef DWORD LBA_t;
# 105 "../Middlewares/FATFS/source/ff.h"
typedef char TCHAR;
# 132 "../Middlewares/FATFS/source/ff.h"
typedef struct {
 BYTE fs_type;
 BYTE pdrv;
 BYTE n_fats;
 BYTE wflag;
 BYTE fsi_flag;
 WORD id;
 WORD n_rootdir;
 WORD csize;




 WCHAR* lfnbuf;


 BYTE* dirbuf;





 DWORD last_clst;
 DWORD free_clst;
# 165 "../Middlewares/FATFS/source/ff.h"
 DWORD n_fatent;
 DWORD fsize;
 LBA_t volbase;
 LBA_t fatbase;
 LBA_t dirbase;
 LBA_t database;

 LBA_t bitbase;

 LBA_t winsect;
 BYTE win[512];
} FATFS;





typedef struct {
 FATFS* fs;
 WORD id;
 BYTE attr;
 BYTE stat;
 DWORD sclust;
 FSIZE_t objsize;

 DWORD n_cont;
 DWORD n_frag;
 DWORD c_scl;
 DWORD c_size;
 DWORD c_ofs;




} FFOBJID;





typedef struct {
 FFOBJID obj;
 BYTE flag;
 BYTE err;
 FSIZE_t fptr;
 DWORD clust;
 LBA_t sect;

 LBA_t dir_sect;
 BYTE* dir_ptr;


 DWORD* cltbl;


 BYTE buf[512];

} FIL;





typedef struct {
 FFOBJID obj;
 DWORD dptr;
 DWORD clust;
 LBA_t sect;
 BYTE* dir;
 BYTE fn[12];

 DWORD blk_ofs;




} DIR;





typedef struct {
 FSIZE_t fsize;
 WORD fdate;
 WORD ftime;
 BYTE fattrib;

 TCHAR altname[12 + 1];
 TCHAR fname[255 + 1];



} FILINFO;





typedef struct {
 BYTE fmt;
 BYTE n_fat;
 UINT align;
 UINT n_root;
 DWORD au_size;
} MKFS_PARM;





typedef enum {
 FR_OK = 0,
 FR_DISK_ERR,
 FR_INT_ERR,
 FR_NOT_READY,
 FR_NO_FILE,
 FR_NO_PATH,
 FR_INVALID_NAME,
 FR_DENIED,
 FR_EXIST,
 FR_INVALID_OBJECT,
 FR_WRITE_PROTECTED,
 FR_INVALID_DRIVE,
 FR_NOT_ENABLED,
 FR_NO_FILESYSTEM,
 FR_MKFS_ABORTED,
 FR_TIMEOUT,
 FR_LOCKED,
 FR_NOT_ENOUGH_CORE,
 FR_TOO_MANY_OPEN_FILES,
 FR_INVALID_PARAMETER
} FRESULT;






FRESULT f_open (FIL* fp, const TCHAR* path, BYTE mode);
FRESULT f_close (FIL* fp);
FRESULT f_read (FIL* fp, void* buff, UINT btr, UINT* br);
FRESULT f_write (FIL* fp, const void* buff, UINT btw, UINT* bw);
FRESULT f_lseek (FIL* fp, FSIZE_t ofs);
FRESULT f_truncate (FIL* fp);
FRESULT f_sync (FIL* fp);
FRESULT f_opendir (DIR* dp, const TCHAR* path);
FRESULT f_closedir (DIR* dp);
FRESULT f_readdir (DIR* dp, FILINFO* fno);
FRESULT f_findfirst (DIR* dp, FILINFO* fno, const TCHAR* path, const TCHAR* pattern);
FRESULT f_findnext (DIR* dp, FILINFO* fno);
FRESULT f_mkdir (const TCHAR* path);
FRESULT f_unlink (const TCHAR* path);
FRESULT f_rename (const TCHAR* path_old, const TCHAR* path_new);
FRESULT f_stat (const TCHAR* path, FILINFO* fno);
FRESULT f_chmod (const TCHAR* path, BYTE attr, BYTE mask);
FRESULT f_utime (const TCHAR* path, const FILINFO* fno);
FRESULT f_chdir (const TCHAR* path);
FRESULT f_chdrive (const TCHAR* path);
FRESULT f_getcwd (TCHAR* buff, UINT len);
FRESULT f_getfree (const TCHAR* path, DWORD* nclst, FATFS** fatfs);
FRESULT f_getlabel (const TCHAR* path, TCHAR* label, DWORD* vsn);
FRESULT f_setlabel (const TCHAR* label);
FRESULT f_forward (FIL* fp, UINT(*func)(const BYTE*,UINT), UINT btf, UINT* bf);
FRESULT f_expand (FIL* fp, FSIZE_t fsz, BYTE opt);
FRESULT f_mount (FATFS* fs, const TCHAR* path, BYTE opt);
FRESULT f_mkfs (const TCHAR* path, const MKFS_PARM* opt, void* work, UINT len);
FRESULT f_fdisk (BYTE pdrv, const LBA_t ptbl[], void* work);
FRESULT f_setcp (WORD cp);
int f_putc (TCHAR c, FIL* fp);
int f_puts (const TCHAR* str, FIL* cp);
int f_printf (FIL* fp, const TCHAR* str, ...);
TCHAR* f_gets (TCHAR* buff, int len, FIL* fp);
# 349 "../Middlewares/FATFS/source/ff.h"
FRESULT dir_sdi (DIR *p,DWORD ofs);
# 358 "../Middlewares/FATFS/source/ff.h"
DWORD get_fattime (void);




WCHAR ff_oem2uni (WCHAR oem, WORD cp);
WCHAR ff_uni2oem (DWORD uni, WORD cp);
DWORD ff_wtoupper (DWORD uni);


void* ff_memalloc (UINT msize);
void ff_memfree (void* mblock);
# 24 "../Middlewares/FATFS/source/ff.c" 2
# 1 "../Middlewares/FATFS/source/diskio.h" 1
# 11 "../Middlewares/FATFS/source/diskio.h"
typedef BYTE DSTATUS;


typedef enum
{
    RES_OK = 0,
    RES_ERROR,
    RES_WRPRT,
    RES_NOTRDY,
    RES_PARERR
} DRESULT;





DSTATUS disk_initialize (BYTE pdrv);
DSTATUS disk_status (BYTE pdrv);
DRESULT disk_read (BYTE pdrv, BYTE *buff, LBA_t sector, UINT count);
DRESULT disk_write (BYTE pdrv, const BYTE *buff, LBA_t sector, UINT count);
DRESULT disk_ioctl (BYTE pdrv, BYTE cmd, void *buff);
# 25 "../Middlewares/FATFS/source/ff.c" 2
# 467 "../Middlewares/FATFS/source/ff.c"
static FATFS* FatFs[2];
static WORD Fsid;
# 516 "../Middlewares/FATFS/source/ff.c"
static const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};
# 599 "../Middlewares/FATFS/source/ff.c"
static const BYTE DbcTbl[] = {0x81, 0xFE, 0x00, 0x00, 0x40, 0x7E, 0x80, 0xFE, 0x00, 0x00};
# 617 "../Middlewares/FATFS/source/ff.c"
static WORD ld_word (const BYTE* ptr)
{
 WORD rv;

 rv = ptr[1];
 rv = rv << 8 | ptr[0];
 return rv;
}

static DWORD ld_dword (const BYTE* ptr)
{
 DWORD rv;

 rv = ptr[3];
 rv = rv << 8 | ptr[2];
 rv = rv << 8 | ptr[1];
 rv = rv << 8 | ptr[0];
 return rv;
}


static QWORD ld_qword (const BYTE* ptr)
{
 QWORD rv;

 rv = ptr[7];
 rv = rv << 8 | ptr[6];
 rv = rv << 8 | ptr[5];
 rv = rv << 8 | ptr[4];
 rv = rv << 8 | ptr[3];
 rv = rv << 8 | ptr[2];
 rv = rv << 8 | ptr[1];
 rv = rv << 8 | ptr[0];
 return rv;
}



static void st_word (BYTE* ptr, WORD val)
{
 *ptr++ = (BYTE)val; val >>= 8;
 *ptr++ = (BYTE)val;
}

static void st_dword (BYTE* ptr, DWORD val)
{
 *ptr++ = (BYTE)val; val >>= 8;
 *ptr++ = (BYTE)val; val >>= 8;
 *ptr++ = (BYTE)val; val >>= 8;
 *ptr++ = (BYTE)val;
}


static void st_qword (BYTE* ptr, QWORD val)
{
 *ptr++ = (BYTE)val; val >>= 8;
 *ptr++ = (BYTE)val; val >>= 8;
 *ptr++ = (BYTE)val; val >>= 8;
 *ptr++ = (BYTE)val; val >>= 8;
 *ptr++ = (BYTE)val; val >>= 8;
 *ptr++ = (BYTE)val; val >>= 8;
 *ptr++ = (BYTE)val; val >>= 8;
 *ptr++ = (BYTE)val;
}
# 691 "../Middlewares/FATFS/source/ff.c"
static int dbc_1st (BYTE c)
{






 if (c >= DbcTbl[0]) {
  if (c <= DbcTbl[1]) return 1;
  if (c >= DbcTbl[2] && c <= DbcTbl[3]) return 1;
 }



 return 0;
}



static int dbc_2nd (BYTE c)
{







 if (c >= DbcTbl[4]) {
  if (c <= DbcTbl[5]) return 1;
  if (c >= DbcTbl[6] && c <= DbcTbl[7]) return 1;
  if (c >= DbcTbl[8] && c <= DbcTbl[9]) return 1;
 }



 return 0;
}





static DWORD tchar2uni (
 const TCHAR** str
)
{
 DWORD uc;
 const TCHAR *p = *str;
# 782 "../Middlewares/FATFS/source/ff.c"
 BYTE b;
 WCHAR wc;

 wc = (BYTE)*p++;
 if (dbc_1st((BYTE)wc)) {
  b = (BYTE)*p++;
  if (!dbc_2nd(b)) return 0xFFFFFFFF;
  wc = (wc << 8) + b;
 }
 if (wc != 0) {
  wc = ff_oem2uni(wc, 936);
  if (wc == 0) return 0xFFFFFFFF;
 }
 uc = wc;


 *str = p;
 return uc;
}



static UINT put_utf (
 DWORD chr,
 TCHAR* buf,
 UINT szb
)
{
# 872 "../Middlewares/FATFS/source/ff.c"
 WCHAR wc;

 wc = ff_uni2oem(chr, 936);
 if (wc >= 0x100) {
  if (szb < 2) return 0;
  *buf++ = (char)(wc >> 8);
  *buf++ = (TCHAR)wc;
  return 2;
 }
 if (wc == 0 || szb < 1) return 0;
 *buf++ = (TCHAR)wc;
 return 1;

}
# 1028 "../Middlewares/FATFS/source/ff.c"
static FRESULT sync_window (
 FATFS* fs
)
{
 FRESULT res = FR_OK;


 if (fs->wflag) {
  if (disk_write(fs->pdrv, fs->win, fs->winsect, 1) == RES_OK) {
   fs->wflag = 0;
   if (fs->winsect - fs->fatbase < fs->fsize) {
    if (fs->n_fats == 2) disk_write(fs->pdrv, fs->win, fs->winsect + fs->fsize, 1);
   }
  } else {
   res = FR_DISK_ERR;
  }
 }
 return res;
}



static FRESULT move_window (
 FATFS* fs,
 LBA_t sect
)
{
 FRESULT res = FR_OK;


 if (sect != fs->winsect) {

  res = sync_window(fs);

  if (res == FR_OK) {
   if (disk_read(fs->pdrv, fs->win, sect, 1) != RES_OK) {
    sect = (LBA_t)0 - 1;
    res = FR_DISK_ERR;
   }
   fs->winsect = sect;
  }
 }
 return res;
}
# 1081 "../Middlewares/FATFS/source/ff.c"
static FRESULT sync_fs (
 FATFS* fs
)
{
 FRESULT res;


 res = sync_window(fs);
 if (res == FR_OK) {
  if (fs->fs_type == 3 && fs->fsi_flag == 1) {

   memset(fs->win, 0, sizeof fs->win);
   st_word(fs->win + 510, 0xAA55);
   st_dword(fs->win + 0, 0x41615252);
   st_dword(fs->win + 484, 0x61417272);
   st_dword(fs->win + 488, fs->free_clst);
   st_dword(fs->win + 492, fs->last_clst);
   fs->winsect = fs->volbase + 1;
   disk_write(fs->pdrv, fs->win, fs->winsect, 1);
   fs->fsi_flag = 0;
  }

  if (disk_ioctl(fs->pdrv, 0, 0) != RES_OK) res = FR_DISK_ERR;
 }

 return res;
}
# 1117 "../Middlewares/FATFS/source/ff.c"
static LBA_t clst2sect (
 FATFS* fs,
 DWORD clst
)
{
 clst -= 2;
 if (clst >= fs->n_fatent - 2) return 0;
 return fs->database + (LBA_t)fs->csize * clst;
}
# 1134 "../Middlewares/FATFS/source/ff.c"
static DWORD get_fat (
 FFOBJID* obj,
 DWORD clst
)
{
 UINT wc, bc;
 DWORD val;
 FATFS *fs = obj->fs;


 if (clst < 2 || clst >= fs->n_fatent) {
  val = 1;

 } else {
  val = 0xFFFFFFFF;

  switch (fs->fs_type) {
  case 1 :
   bc = (UINT)clst; bc += bc / 2;
   if (move_window(fs, fs->fatbase + (bc / ((UINT)512))) != FR_OK) break;
   wc = fs->win[bc++ % ((UINT)512)];
   if (move_window(fs, fs->fatbase + (bc / ((UINT)512))) != FR_OK) break;
   wc |= fs->win[bc % ((UINT)512)] << 8;
   val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
   break;

  case 2 :
   if (move_window(fs, fs->fatbase + (clst / (((UINT)512) / 2))) != FR_OK) break;
   val = ld_word(fs->win + clst * 2 % ((UINT)512));
   break;

  case 3 :
   if (move_window(fs, fs->fatbase + (clst / (((UINT)512) / 4))) != FR_OK) break;
   val = ld_dword(fs->win + clst * 4 % ((UINT)512)) & 0x0FFFFFFF;
   break;

  case 4 :
   if ((obj->objsize != 0 && obj->sclust != 0) || obj->stat == 0) {
    DWORD cofs = clst - obj->sclust;
    DWORD clen = (DWORD)((LBA_t)((obj->objsize - 1) / ((UINT)512)) / fs->csize);

    if (obj->stat == 2 && cofs <= clen) {
     val = (cofs == clen) ? 0x7FFFFFFF : clst + 1;
     break;
    }
    if (obj->stat == 3 && cofs < obj->n_cont) {
     val = clst + 1;
     break;
    }
    if (obj->stat != 2) {
     if (obj->n_frag != 0) {
      val = 0x7FFFFFFF;
     } else {
      if (move_window(fs, fs->fatbase + (clst / (((UINT)512) / 4))) != FR_OK) break;
      val = ld_dword(fs->win + clst * 4 % ((UINT)512)) & 0x7FFFFFFF;
     }
     break;
    }
   }
   val = 1;
   break;

  default:
   val = 1;
  }
 }

 return val;
}
# 1212 "../Middlewares/FATFS/source/ff.c"
static FRESULT put_fat (
 FATFS* fs,
 DWORD clst,
 DWORD val
)
{
 UINT bc;
 BYTE *p;
 FRESULT res = FR_INT_ERR;


 if (clst >= 2 && clst < fs->n_fatent) {
  switch (fs->fs_type) {
  case 1:
   bc = (UINT)clst; bc += bc / 2;
   res = move_window(fs, fs->fatbase + (bc / ((UINT)512)));
   if (res != FR_OK) break;
   p = fs->win + bc++ % ((UINT)512);
   *p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
   fs->wflag = 1;
   res = move_window(fs, fs->fatbase + (bc / ((UINT)512)));
   if (res != FR_OK) break;
   p = fs->win + bc % ((UINT)512);
   *p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
   fs->wflag = 1;
   break;

  case 2:
   res = move_window(fs, fs->fatbase + (clst / (((UINT)512) / 2)));
   if (res != FR_OK) break;
   st_word(fs->win + clst * 2 % ((UINT)512), (WORD)val);
   fs->wflag = 1;
   break;

  case 3:

  case 4:

   res = move_window(fs, fs->fatbase + (clst / (((UINT)512) / 4)));
   if (res != FR_OK) break;
   if (!1 || fs->fs_type != 4) {
    val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % ((UINT)512)) & 0xF0000000);
   }
   st_dword(fs->win + clst * 4 % ((UINT)512), val);
   fs->wflag = 1;
   break;
  }
 }
 return res;
}
# 1277 "../Middlewares/FATFS/source/ff.c"
static DWORD find_bitmap (
 FATFS* fs,
 DWORD clst,
 DWORD ncl
)
{
 BYTE bm, bv;
 UINT i;
 DWORD val, scl, ctr;


 clst -= 2;
 if (clst >= fs->n_fatent - 2) clst = 0;
 scl = val = clst; ctr = 0;
 for (;;) {
  if (move_window(fs, fs->bitbase + val / 8 / ((UINT)512)) != FR_OK) return 0xFFFFFFFF;
  i = val / 8 % ((UINT)512); bm = 1 << (val % 8);
  do {
   do {
    bv = fs->win[i] & bm; bm <<= 1;
    if (++val >= fs->n_fatent - 2) {
     val = 0; bm = 0; i = ((UINT)512);
    }
    if (bv == 0) {
     if (++ctr == ncl) return scl + 2;
    } else {
     scl = val; ctr = 0;
    }
    if (val == clst) return 0;
   } while (bm != 0);
   bm = 1;
  } while (++i < ((UINT)512));
 }
}






static FRESULT change_bitmap (
 FATFS* fs,
 DWORD clst,
 DWORD ncl,
 int bv
)
{
 BYTE bm;
 UINT i;
 LBA_t sect;


 clst -= 2;
 sect = fs->bitbase + clst / 8 / ((UINT)512);
 i = clst / 8 % ((UINT)512);
 bm = 1 << (clst % 8);
 for (;;) {
  if (move_window(fs, sect++) != FR_OK) return FR_DISK_ERR;
  do {
   do {
    if (bv == (int)((fs->win[i] & bm) != 0)) return FR_INT_ERR;
    fs->win[i] ^= bm;
    fs->wflag = 1;
    if (--ncl == 0) return FR_OK;
   } while (bm <<= 1);
   bm = 1;
  } while (++i < ((UINT)512));
  i = 0;
 }
}






static FRESULT fill_first_frag (
 FFOBJID* obj
)
{
 FRESULT res;
 DWORD cl, n;


 if (obj->stat == 3) {
  for (cl = obj->sclust, n = obj->n_cont; n; cl++, n--) {
   res = put_fat(obj->fs, cl, cl + 1);
   if (res != FR_OK) return res;
  }
  obj->stat = 0;
 }
 return FR_OK;
}






static FRESULT fill_last_frag (
 FFOBJID* obj,
 DWORD lcl,
 DWORD term
)
{
 FRESULT res;


 while (obj->n_frag > 0) {
  res = put_fat(obj->fs, lcl - obj->n_frag + 1, (obj->n_frag > 1) ? lcl - obj->n_frag + 2 : term);
  if (res != FR_OK) return res;
  obj->n_frag--;
 }
 return FR_OK;
}
# 1402 "../Middlewares/FATFS/source/ff.c"
static FRESULT remove_chain (
 FFOBJID* obj,
 DWORD clst,
 DWORD pclst
)
{
 FRESULT res = FR_OK;
 DWORD nxt;
 FATFS *fs = obj->fs;

 DWORD scl = clst, ecl = clst;





 if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;


 if (pclst != 0 && (!1 || fs->fs_type != 4 || obj->stat != 2)) {
  res = put_fat(fs, pclst, 0xFFFFFFFF);
  if (res != FR_OK) return res;
 }


 do {
  nxt = get_fat(obj, clst);
  if (nxt == 0) break;
  if (nxt == 1) return FR_INT_ERR;
  if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;
  if (!1 || fs->fs_type != 4) {
   res = put_fat(fs, clst, 0);
   if (res != FR_OK) return res;
  }
  if (fs->free_clst < fs->n_fatent - 2) {
   fs->free_clst++;
   fs->fsi_flag |= 1;
  }

  if (ecl + 1 == nxt) {
   ecl = nxt;
  } else {

   if (fs->fs_type == 4) {
    res = change_bitmap(fs, scl, ecl - scl + 1, 0);
    if (res != FR_OK) return res;
   }






   scl = ecl = nxt;
  }

  clst = nxt;
 } while (clst < fs->n_fatent);



 if (fs->fs_type == 4) {
  if (pclst == 0) {
   obj->stat = 0;
  } else {
   if (obj->stat == 0) {
    clst = obj->sclust;
    while (clst != pclst) {
     nxt = get_fat(obj, clst);
     if (nxt < 2) return FR_INT_ERR;
     if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;
     if (nxt != clst + 1) break;
     clst++;
    }
    if (clst == pclst) {
     obj->stat = 2;
    }
   } else {
    if (obj->stat == 3 && pclst >= obj->sclust && pclst <= obj->sclust + obj->n_cont) {
     obj->stat = 2;
    }
   }
  }
 }

 return FR_OK;
}
# 1497 "../Middlewares/FATFS/source/ff.c"
static DWORD create_chain (
 FFOBJID* obj,
 DWORD clst
)
{
 DWORD cs, ncl, scl;
 FRESULT res;
 FATFS *fs = obj->fs;


 if (clst == 0) {
  scl = fs->last_clst;
  if (scl == 0 || scl >= fs->n_fatent) scl = 1;
 }
 else {
  cs = get_fat(obj, clst);
  if (cs < 2) return 1;
  if (cs == 0xFFFFFFFF) return cs;
  if (cs < fs->n_fatent) return cs;
  scl = clst;
 }
 if (fs->free_clst == 0) return 0;


 if (fs->fs_type == 4) {
  ncl = find_bitmap(fs, scl, 1);
  if (ncl == 0 || ncl == 0xFFFFFFFF) return ncl;
  res = change_bitmap(fs, ncl, 1, 1);
  if (res == FR_INT_ERR) return 1;
  if (res == FR_DISK_ERR) return 0xFFFFFFFF;
  if (clst == 0) {
   obj->stat = 2;
  } else {
   if (obj->stat == 2 && ncl != scl + 1) {
    obj->n_cont = scl - obj->sclust;
    obj->stat = 3;
   }
  }
  if (obj->stat != 2) {
   if (ncl == clst + 1) {
    obj->n_frag = obj->n_frag ? obj->n_frag + 1 : 2;
   } else {
    if (obj->n_frag == 0) obj->n_frag = 1;
    res = fill_last_frag(obj, clst, ncl);
    if (res == FR_OK) obj->n_frag = 1;
   }
  }
 } else

 {
  ncl = 0;
  if (scl == clst) {
   ncl = scl + 1;
   if (ncl >= fs->n_fatent) ncl = 2;
   cs = get_fat(obj, ncl);
   if (cs == 1 || cs == 0xFFFFFFFF) return cs;
   if (cs != 0) {
    cs = fs->last_clst;
    if (cs >= 2 && cs < fs->n_fatent) scl = cs;
    ncl = 0;
   }
  }
  if (ncl == 0) {
   ncl = scl;
   for (;;) {
    ncl++;
    if (ncl >= fs->n_fatent) {
     ncl = 2;
     if (ncl > scl) return 0;
    }
    cs = get_fat(obj, ncl);
    if (cs == 0) break;
    if (cs == 1 || cs == 0xFFFFFFFF) return cs;
    if (ncl == scl) return 0;
   }
  }
  res = put_fat(fs, ncl, 0xFFFFFFFF);
  if (res == FR_OK && clst != 0) {
   res = put_fat(fs, clst, ncl);
  }
 }

 if (res == FR_OK) {
  fs->last_clst = ncl;
  if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
  fs->fsi_flag |= 1;
 } else {
  ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
 }

 return ncl;
}
# 1600 "../Middlewares/FATFS/source/ff.c"
static DWORD clmt_clust (
 FIL* fp,
 FSIZE_t ofs
)
{
 DWORD cl, ncl, *tbl;
 FATFS *fs = fp->obj.fs;


 tbl = fp->cltbl + 1;
 cl = (DWORD)(ofs / ((UINT)512) / fs->csize);
 for (;;) {
  ncl = *tbl++;
  if (ncl == 0) return 0;
  if (cl < ncl) break;
  cl -= ncl; tbl++;
 }
 return cl + *tbl;
}
# 1630 "../Middlewares/FATFS/source/ff.c"
static FRESULT dir_clear (
 FATFS *fs,
 DWORD clst
)
{
 LBA_t sect;
 UINT n, szb;
 BYTE *ibuf;


 if (sync_window(fs) != FR_OK) return FR_DISK_ERR;
 sect = clst2sect(fs, clst);
 fs->winsect = sect;
 memset(fs->win, 0, sizeof fs->win);


 for (szb = ((DWORD)fs->csize * ((UINT)512) >= 0x8000) ? 0x8000 : fs->csize * ((UINT)512), ibuf = 0; szb > ((UINT)512) && (ibuf = ff_memalloc(szb)) == 0; szb /= 2) ;
 if (szb > ((UINT)512)) {
  memset(ibuf, 0, szb);
  szb /= ((UINT)512);
  for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;
  ff_memfree(ibuf);
 } else

 {
  ibuf = fs->win; szb = 1;
  for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;
 }
 return (n == fs->csize) ? FR_OK : FR_DISK_ERR;
}
# 1670 "../Middlewares/FATFS/source/ff.c"
FRESULT dir_sdi (
 DIR* dp,
 DWORD ofs
)
{
 DWORD csz, clst;
 FATFS *fs = dp->obj.fs;


 if (ofs >= (DWORD)((1 && fs->fs_type == 4) ? 0x10000000 : 0x200000) || ofs % 32) {
  return FR_INT_ERR;
 }
 dp->dptr = ofs;
 clst = dp->obj.sclust;
 if (clst == 0 && fs->fs_type >= 3) {
  clst = (DWORD)fs->dirbase;
  if (1) dp->obj.stat = 0;
 }

 if (clst == 0) {
  if (ofs / 32 >= fs->n_rootdir) return FR_INT_ERR;
  dp->sect = fs->dirbase;

 } else {
  csz = (DWORD)fs->csize * ((UINT)512);
  while (ofs >= csz) {
   clst = get_fat(&dp->obj, clst);
   if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
   if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;
   ofs -= csz;
  }
  dp->sect = clst2sect(fs, clst);
 }
 dp->clust = clst;
 if (dp->sect == 0) return FR_INT_ERR;
 dp->sect += ofs / ((UINT)512);
 dp->dir = fs->win + (ofs % ((UINT)512));

 return FR_OK;
}
# 1718 "../Middlewares/FATFS/source/ff.c"
static FRESULT dir_next (
 DIR* dp,
 int stretch
)
{
 DWORD ofs, clst;
 FATFS *fs = dp->obj.fs;


 ofs = dp->dptr + 32;
 if (ofs >= (DWORD)((1 && fs->fs_type == 4) ? 0x10000000 : 0x200000)) dp->sect = 0;
 if (dp->sect == 0) return FR_NO_FILE;

 if (ofs % ((UINT)512) == 0) {
  dp->sect++;

  if (dp->clust == 0) {
   if (ofs / 32 >= fs->n_rootdir) {
    dp->sect = 0; return FR_NO_FILE;
   }
  }
  else {
   if ((ofs / ((UINT)512) & (fs->csize - 1)) == 0) {
    clst = get_fat(&dp->obj, dp->clust);
    if (clst <= 1) return FR_INT_ERR;
    if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    if (clst >= fs->n_fatent) {

     if (!stretch) {
      dp->sect = 0; return FR_NO_FILE;
     }
     clst = create_chain(&dp->obj, dp->clust);
     if (clst == 0) return FR_DENIED;
     if (clst == 1) return FR_INT_ERR;
     if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
     if (dir_clear(fs, clst) != FR_OK) return FR_DISK_ERR;
     if (1) dp->obj.stat |= 4;




    }
    dp->clust = clst;
    dp->sect = clst2sect(fs, clst);
   }
  }
 }
 dp->dptr = ofs;
 dp->dir = fs->win + ofs % ((UINT)512);

 return FR_OK;
}
# 1779 "../Middlewares/FATFS/source/ff.c"
static FRESULT dir_alloc (
 DIR* dp,
 UINT n_ent
)
{
 FRESULT res;
 UINT n;
 FATFS *fs = dp->obj.fs;


 res = dir_sdi(dp, 0);
 if (res == FR_OK) {
  n = 0;
  do {
   res = move_window(fs, dp->sect);
   if (res != FR_OK) break;

   if ((fs->fs_type == 4) ? (int)((dp->dir[0] & 0x80) == 0) : (int)(dp->dir[0] == 0xE5 || dp->dir[0] == 0)) {



    if (++n == n_ent) break;
   } else {
    n = 0;
   }
   res = dir_next(dp, 1);
  } while (res == FR_OK);
 }

 if (res == FR_NO_FILE) res = FR_DENIED;
 return res;
}
# 1821 "../Middlewares/FATFS/source/ff.c"
static DWORD ld_clust (
 FATFS* fs,
 const BYTE* dir
)
{
 DWORD cl;

 cl = ld_word(dir + 26);
 if (fs->fs_type == 3) {
  cl |= (DWORD)ld_word(dir + 20) << 16;
 }

 return cl;
}



static void st_clust (
 FATFS* fs,
 BYTE* dir,
 DWORD cl
)
{
 st_word(dir + 26, (WORD)cl);
 if (fs->fs_type == 3) {
  st_word(dir + 20, (WORD)(cl >> 16));
 }
}
# 1858 "../Middlewares/FATFS/source/ff.c"
static int cmp_lfn (
 const WCHAR* lfnbuf,
 BYTE* dir
)
{
 UINT i, s;
 WCHAR wc, uc;


 if (ld_word(dir + 26) != 0) return 0;

 i = ((dir[0] & 0x3F) - 1) * 13;

 for (wc = 1, s = 0; s < 13; s++) {
  uc = ld_word(dir + LfnOfs[s]);
  if (wc != 0) {
   if (i >= 255 + 1 || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {
    return 0;
   }
   wc = uc;
  } else {
   if (uc != 0xFFFF) return 0;
  }
 }

 if ((dir[0] & 0x40) && wc && lfnbuf[i]) return 0;

 return 1;
}







static int pick_lfn (
 WCHAR* lfnbuf,
 BYTE* dir
)
{
 UINT i, s;
 WCHAR wc, uc;


 if (ld_word(dir + 26) != 0) return 0;

 i = ((dir[0] & ~0x40) - 1) * 13;

 for (wc = 1, s = 0; s < 13; s++) {
  uc = ld_word(dir + LfnOfs[s]);
  if (wc != 0) {
   if (i >= 255 + 1) return 0;
   lfnbuf[i++] = wc = uc;
  } else {
   if (uc != 0xFFFF) return 0;
  }
 }

 if (dir[0] & 0x40 && wc != 0) {
  if (i >= 255 + 1) return 0;
  lfnbuf[i] = 0;
 }

 return 1;
}
# 1932 "../Middlewares/FATFS/source/ff.c"
static void put_lfn (
 const WCHAR* lfn,
 BYTE* dir,
 BYTE ord,
 BYTE sum
)
{
 UINT i, s;
 WCHAR wc;


 dir[13] = sum;
 dir[11] = 0x0F;
 dir[12] = 0;
 st_word(dir + 26, 0);

 i = (ord - 1) * 13;
 s = wc = 0;
 do {
  if (wc != 0xFFFF) wc = lfn[i++];
  st_word(dir + LfnOfs[s], wc);
  if (wc == 0) wc = 0xFFFF;
 } while (++s < 13);
 if (wc == 0xFFFF || !lfn[i]) ord |= 0x40;
 dir[0] = ord;
}
# 1969 "../Middlewares/FATFS/source/ff.c"
static void gen_numname (
 BYTE* dst,
 const BYTE* src,
 const WCHAR* lfn,
 UINT seq
)
{
 BYTE ns[8], c;
 UINT i, j;
 WCHAR wc;
 DWORD sreg;


 memcpy(dst, src, 11);

 if (seq > 5) {
  sreg = seq;
  while (*lfn) {
   wc = *lfn++;
   for (i = 0; i < 16; i++) {
    sreg = (sreg << 1) + (wc & 1);
    wc >>= 1;
    if (sreg & 0x10000) sreg ^= 0x11021;
   }
  }
  seq = (UINT)sreg;
 }


 i = 7;
 do {
  c = (BYTE)((seq % 16) + '0'); seq /= 16;
  if (c > '9') c += 7;
  ns[i--] = c;
 } while (i && seq);
 ns[i] = '~';


 for (j = 0; j < i && dst[j] != ' '; j++) {
  if (dbc_1st(dst[j])) {
   if (j == i - 1) break;
   j++;
  }
 }
 do {
  dst[j++] = (i < 8) ? ns[i++] : ' ';
 } while (j < 8);
}
# 2026 "../Middlewares/FATFS/source/ff.c"
static BYTE sum_sfn (
 const BYTE* dir
)
{
 BYTE sum = 0;
 UINT n = 11;

 do {
  sum = (sum >> 1) + (sum << 7) + *dir++;
 } while (--n);
 return sum;
}
# 2048 "../Middlewares/FATFS/source/ff.c"
static WORD xdir_sum (
 const BYTE* dir
)
{
 UINT i, szblk;
 WORD sum;


 szblk = (dir[1] + 1) * 32;
 for (i = sum = 0; i < szblk; i++) {
  if (i == 2) {
   i++;
  } else {
   sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + dir[i];
  }
 }
 return sum;
}



static WORD xname_sum (
 const WCHAR* name
)
{
 WCHAR chr;
 WORD sum = 0;


 while ((chr = *name++) != 0) {
  chr = (WCHAR)ff_wtoupper(chr);
  sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + (chr & 0xFF);
  sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + (chr >> 8);
 }
 return sum;
}



static DWORD xsum32 (
 BYTE dat,
 DWORD sum
)
{
 sum = ((sum & 1) ? 0x80000000 : 0) + (sum >> 1) + dat;
 return sum;
}
# 2103 "../Middlewares/FATFS/source/ff.c"
static FRESULT load_xdir (
 DIR* dp
)
{
 FRESULT res;
 UINT i, sz_ent;
 BYTE *dirb = dp->obj.fs->dirbuf;



 res = move_window(dp->obj.fs, dp->sect);
 if (res != FR_OK) return res;
 if (dp->dir[0] != 0x85) return FR_INT_ERR;
 memcpy(dirb + 0 * 32, dp->dir, 32);
 sz_ent = (dirb[1] + 1) * 32;
 if (sz_ent < 3 * 32 || sz_ent > 19 * 32) return FR_INT_ERR;


 res = dir_next(dp, 0);
 if (res == FR_NO_FILE) res = FR_INT_ERR;
 if (res != FR_OK) return res;
 res = move_window(dp->obj.fs, dp->sect);
 if (res != FR_OK) return res;
 if (dp->dir[0] != 0xC0) return FR_INT_ERR;
 memcpy(dirb + 1 * 32, dp->dir, 32);
 if (((dirb[35] + 44U) / 15 * 32) > sz_ent) return FR_INT_ERR;


 i = 2 * 32;
 do {
  res = dir_next(dp, 0);
  if (res == FR_NO_FILE) res = FR_INT_ERR;
  if (res != FR_OK) return res;
  res = move_window(dp->obj.fs, dp->sect);
  if (res != FR_OK) return res;
  if (dp->dir[0] != 0xC1) return FR_INT_ERR;
  if (i < ((255 + 44U) / 15 * 32)) memcpy(dirb + i, dp->dir, 32);
 } while ((i += 32) < sz_ent);


 if (i <= ((255 + 44U) / 15 * 32)) {
  if (xdir_sum(dirb) != ld_word(dirb + 2)) return FR_INT_ERR;
 }
 return FR_OK;
}






static void init_alloc_info (
 FATFS* fs,
 FFOBJID* obj
)
{
 obj->sclust = ld_dword(fs->dirbuf + 52);
 obj->objsize = ld_qword(fs->dirbuf + 56);
 obj->stat = fs->dirbuf[33] & 2;
 obj->n_frag = 0;
}
# 2172 "../Middlewares/FATFS/source/ff.c"
static FRESULT load_obj_xdir (
 DIR* dp,
 const FFOBJID* obj
)
{
 FRESULT res;


 dp->obj.fs = obj->fs;
 dp->obj.sclust = obj->c_scl;
 dp->obj.stat = (BYTE)obj->c_size;
 dp->obj.objsize = obj->c_size & 0xFFFFFF00;
 dp->obj.n_frag = 0;
 dp->blk_ofs = obj->c_ofs;

 res = dir_sdi(dp, dp->blk_ofs);
 if (res == FR_OK) {
  res = load_xdir(dp);
 }
 return res;
}
# 2201 "../Middlewares/FATFS/source/ff.c"
static FRESULT store_xdir (
 DIR* dp
)
{
 FRESULT res;
 UINT nent;
 BYTE *dirb = dp->obj.fs->dirbuf;


 st_word(dirb + 2, xdir_sum(dirb));
 nent = dirb[1] + 1;


 res = dir_sdi(dp, dp->blk_ofs);
 while (res == FR_OK) {
  res = move_window(dp->obj.fs, dp->sect);
  if (res != FR_OK) break;
  memcpy(dp->dir, dirb, 32);
  dp->obj.fs->wflag = 1;
  if (--nent == 0) break;
  dirb += 32;
  res = dir_next(dp, 0);
 }
 return (res == FR_OK || res == FR_DISK_ERR) ? res : FR_INT_ERR;
}







static void create_xdir (
 BYTE* dirb,
 const WCHAR* lfn
)
{
 UINT i;
 BYTE nc1, nlen;
 WCHAR wc;



 memset(dirb, 0, 2 * 32);
 dirb[0 * 32 + 0] = 0x85;
 dirb[1 * 32 + 0] = 0xC0;


 i = 32 * 2;
 nlen = nc1 = 0; wc = 1;
 do {
  dirb[i++] = 0xC1; dirb[i++] = 0;
  do {
   if (wc != 0 && (wc = lfn[nlen]) != 0) nlen++;
   st_word(dirb + i, wc);
   i += 2;
  } while (i % 32 != 0);
  nc1++;
 } while (lfn[nlen]);

 dirb[35] = nlen;
 dirb[1] = 1 + nc1;
 st_word(dirb + 36, xname_sum(lfn));
}
# 2279 "../Middlewares/FATFS/source/ff.c"
static FRESULT dir_read (
 DIR* dp,
 int vol
)
{
 FRESULT res = FR_NO_FILE;
 FATFS *fs = dp->obj.fs;
 BYTE attr, b;

 BYTE ord = 0xFF, sum = 0xFF;


 while (dp->sect) {
  res = move_window(fs, dp->sect);
  if (res != FR_OK) break;
  b = dp->dir[0];
  if (b == 0) {
   res = FR_NO_FILE; break;
  }

  if (fs->fs_type == 4) {
   if (1 && vol) {
    if (b == 0x83) break;
   } else {
    if (b == 0x85) {
     dp->blk_ofs = dp->dptr;
     res = load_xdir(dp);
     if (res == FR_OK) {
      dp->obj.attr = fs->dirbuf[4] & 0x3F;
     }
     break;
    }
   }
  } else

  {
   dp->obj.attr = attr = dp->dir[11] & 0x3F;

   if (b == 0xE5 || b == '.' || (int)((attr & ~0x20) == 0x08) != vol) {
    ord = 0xFF;
   } else {
    if (attr == 0x0F) {
     if (b & 0x40) {
      sum = dp->dir[13];
      b &= (BYTE)~0x40; ord = b;
      dp->blk_ofs = dp->dptr;
     }

     ord = (b == ord && sum == dp->dir[13] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
    } else {
     if (ord != 0 || sum != sum_sfn(dp->dir)) {
      dp->blk_ofs = 0xFFFFFFFF;
     }
     break;
    }
   }





  }
  res = dir_next(dp, 0);
  if (res != FR_OK) break;
 }

 if (res != FR_OK) dp->sect = 0;
 return res;
}
# 2357 "../Middlewares/FATFS/source/ff.c"
static FRESULT dir_find (
 DIR* dp
)
{
 FRESULT res;
 FATFS *fs = dp->obj.fs;
 BYTE c;

 BYTE a, ord, sum;


 res = dir_sdi(dp, 0);
 if (res != FR_OK) return res;

 if (fs->fs_type == 4) {
  BYTE nc;
  UINT di, ni;
  WORD hash = xname_sum(fs->lfnbuf);

  while ((res = dir_read(dp, 0)) == FR_OK) {



   if (ld_word(fs->dirbuf + 36) != hash) continue;
   for (nc = fs->dirbuf[35], di = 32 * 2, ni = 0; nc; nc--, di += 2, ni++) {
    if ((di % 32) == 0) di += 2;
    if (ff_wtoupper(ld_word(fs->dirbuf + di)) != ff_wtoupper(fs->lfnbuf[ni])) break;
   }
   if (nc == 0 && !fs->lfnbuf[ni]) break;
  }
  return res;
 }



 ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;

 do {
  res = move_window(fs, dp->sect);
  if (res != FR_OK) break;
  c = dp->dir[0];
  if (c == 0) { res = FR_NO_FILE; break; }

  dp->obj.attr = a = dp->dir[11] & 0x3F;
  if (c == 0xE5 || ((a & 0x08) && a != 0x0F)) {
   ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;
  } else {
   if (a == 0x0F) {
    if (!(dp->fn[11] & 0x40)) {
     if (c & 0x40) {
      sum = dp->dir[13];
      c &= (BYTE)~0x40; ord = c;
      dp->blk_ofs = dp->dptr;
     }

     ord = (c == ord && sum == dp->dir[13] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
    }
   } else {
    if (ord == 0 && sum == sum_sfn(dp->dir)) break;
    if (!(dp->fn[11] & 0x01) && !memcmp(dp->dir, dp->fn, 11)) break;
    ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;
   }
  }




  res = dir_next(dp, 0);
 } while (res == FR_OK);

 return res;
}
# 2438 "../Middlewares/FATFS/source/ff.c"
static FRESULT dir_register (
 DIR* dp
)
{
 FRESULT res;
 FATFS *fs = dp->obj.fs;

 UINT n, len, n_ent;
 BYTE sn[12], sum;


 if (dp->fn[11] & (0x20 | 0x80)) return FR_INVALID_NAME;
 for (len = 0; fs->lfnbuf[len]; len++) ;


 if (fs->fs_type == 4) {
  n_ent = (len + 14) / 15 + 2;
  res = dir_alloc(dp, n_ent);
  if (res != FR_OK) return res;
  dp->blk_ofs = dp->dptr - 32 * (n_ent - 1);

  if (dp->obj.stat & 4) {
   dp->obj.stat &= ~4;
   res = fill_first_frag(&dp->obj);
   if (res != FR_OK) return res;
   res = fill_last_frag(&dp->obj, dp->clust, 0xFFFFFFFF);
   if (res != FR_OK) return res;
   if (dp->obj.sclust != 0) {
    DIR dj;

    res = load_obj_xdir(&dj, &dp->obj);
    if (res != FR_OK) return res;
    dp->obj.objsize += (DWORD)fs->csize * ((UINT)512);
    st_qword(fs->dirbuf + 56, dp->obj.objsize);
    st_qword(fs->dirbuf + 40, dp->obj.objsize);
    fs->dirbuf[33] = dp->obj.stat | 1;
    res = store_xdir(&dj);
    if (res != FR_OK) return res;
   }
  }

  create_xdir(fs->dirbuf, fs->lfnbuf);
  return FR_OK;
 }


 memcpy(sn, dp->fn, 12);
 if (sn[11] & 0x01) {
  dp->fn[11] = 0x40;
  for (n = 1; n < 100; n++) {
   gen_numname(dp->fn, sn, fs->lfnbuf, n);
   res = dir_find(dp);
   if (res != FR_OK) break;
  }
  if (n == 100) return FR_DENIED;
  if (res != FR_NO_FILE) return res;
  dp->fn[11] = sn[11];
 }


 n_ent = (sn[11] & 0x02) ? (len + 12) / 13 + 1 : 1;
 res = dir_alloc(dp, n_ent);
 if (res == FR_OK && --n_ent) {
  res = dir_sdi(dp, dp->dptr - n_ent * 32);
  if (res == FR_OK) {
   sum = sum_sfn(dp->fn);
   do {
    res = move_window(fs, dp->sect);
    if (res != FR_OK) break;
    put_lfn(fs->lfnbuf, dp->dir, (BYTE)n_ent, sum);
    fs->wflag = 1;
    res = dir_next(dp, 0);
   } while (res == FR_OK && --n_ent);
  }
 }







 if (res == FR_OK) {
  res = move_window(fs, dp->sect);
  if (res == FR_OK) {
   memset(dp->dir, 0, 32);
   memcpy(dp->dir + 0, dp->fn, 11);

   dp->dir[12] = dp->fn[11] & (0x08 | 0x10);

   fs->wflag = 1;
  }
 }

 return res;
}
# 2544 "../Middlewares/FATFS/source/ff.c"
static FRESULT dir_remove (
 DIR* dp
)
{
 FRESULT res;
 FATFS *fs = dp->obj.fs;

 DWORD last = dp->dptr;

 res = (dp->blk_ofs == 0xFFFFFFFF) ? FR_OK : dir_sdi(dp, dp->blk_ofs);
 if (res == FR_OK) {
  do {
   res = move_window(fs, dp->sect);
   if (res != FR_OK) break;
   if (1 && fs->fs_type == 4) {
    dp->dir[0] &= 0x7F;
   } else {
    dp->dir[0] = 0xE5;
   }
   fs->wflag = 1;
   if (dp->dptr >= last) break;
   res = dir_next(dp, 0);
  } while (res == FR_OK);
  if (res == FR_NO_FILE) res = FR_INT_ERR;
 }
# 2578 "../Middlewares/FATFS/source/ff.c"
 return res;
}
# 2590 "../Middlewares/FATFS/source/ff.c"
static void get_fileinfo (
 DIR* dp,
 FILINFO* fno
)
{
 UINT si, di;

 BYTE lcf;
 WCHAR wc, hs;
 FATFS *fs = dp->obj.fs;
 UINT nw;





 fno->fname[0] = 0;
 if (dp->sect == 0) return;



 if (fs->fs_type == 4) {
  UINT nc = 0;

  si = 32 * 2; di = 0;
  hs = 0;
  while (nc < fs->dirbuf[35]) {
   if (si >= ((255 + 44U) / 15 * 32)) { di = 0; break; }
   if ((si % 32) == 0) si += 2;
   wc = ld_word(fs->dirbuf + si); si += 2; nc++;
   if (hs == 0 && ((wc) >= 0xD800 && (wc) <= 0xDFFF)) {
    hs = wc; continue;
   }
   nw = put_utf((DWORD)hs << 16 | wc, &fno->fname[di], 255 - di);
   if (nw == 0) { di = 0; break; }
   di += nw;
   hs = 0;
  }
  if (hs != 0) di = 0;
  if (di == 0) fno->fname[di++] = '?';
  fno->fname[di] = 0;
  fno->altname[0] = 0;

  fno->fattrib = fs->dirbuf[4] & 0x37;
  fno->fsize = (fno->fattrib & 0x10) ? 0 : ld_qword(fs->dirbuf + 56);
  fno->ftime = ld_word(fs->dirbuf + 12 + 0);
  fno->fdate = ld_word(fs->dirbuf + 12 + 2);
  return;
 } else

 {
  if (dp->blk_ofs != 0xFFFFFFFF) {
   si = di = 0;
   hs = 0;
   while (fs->lfnbuf[si] != 0) {
    wc = fs->lfnbuf[si++];
    if (hs == 0 && ((wc) >= 0xD800 && (wc) <= 0xDFFF)) {
     hs = wc; continue;
    }
    nw = put_utf((DWORD)hs << 16 | wc, &fno->fname[di], 255 - di);
    if (nw == 0) { di = 0; break; }
    di += nw;
    hs = 0;
   }
   if (hs != 0) di = 0;
   fno->fname[di] = 0;
  }
 }

 si = di = 0;
 while (si < 11) {
  wc = dp->dir[si++];
  if (wc == ' ') continue;
  if (wc == 0x05) wc = 0xE5;
  if (si == 9 && di < 12) fno->altname[di++] = '.';
# 2675 "../Middlewares/FATFS/source/ff.c"
  fno->altname[di++] = (TCHAR)wc;

 }
 fno->altname[di] = 0;

 if (fno->fname[0] == 0) {
  if (di == 0) {
   fno->fname[di++] = '?';
  } else {
   for (si = di = 0, lcf = 0x08; fno->altname[si]; si++, di++) {
    wc = (WCHAR)fno->altname[si];
    if (wc == '.') lcf = 0x10;
    if (((wc) >= 'A' && (wc) <= 'Z') && (dp->dir[12] & lcf)) wc += 0x20;
    fno->fname[di] = (TCHAR)wc;
   }
  }
  fno->fname[di] = 0;
  if (!dp->dir[12]) fno->altname[0] = 0;
 }
# 2707 "../Middlewares/FATFS/source/ff.c"
 fno->fattrib = dp->dir[11] & 0x3F;
 fno->fsize = ld_dword(dp->dir + 28);
 fno->ftime = ld_word(dp->dir + 22 + 0);
 fno->fdate = ld_word(dp->dir + 22 + 2);
}
# 2805 "../Middlewares/FATFS/source/ff.c"
static FRESULT create_name (
 DIR* dp,
 const TCHAR** path
)
{

 BYTE b, cf;
 WCHAR wc, *lfn;
 DWORD uc;
 UINT i, ni, si, di;
 const TCHAR *p;



 p = *path; lfn = dp->obj.fs->lfnbuf; di = 0;
 for (;;) {
  uc = tchar2uni(&p);
  if (uc == 0xFFFFFFFF) return FR_INVALID_NAME;
  if (uc >= 0x10000) lfn[di++] = (WCHAR)(uc >> 16);
  wc = (WCHAR)uc;
  if (wc < ' ' || ((wc) == '/' || (wc) == '\\')) break;
  if (wc < 0x80 && strchr("*:<>|\"\?\x7F", (int)wc)) return FR_INVALID_NAME;
  if (di >= 255) return FR_INVALID_NAME;
  lfn[di++] = wc;
 }
 if (wc < ' ') {
  cf = 0x04;
 } else {
  while (((*p) == '/' || (*p) == '\\')) p++;
  cf = 0;
  if (((UINT)(*p) < (3 ? ' ' : '!'))) cf = 0x04;
 }
 *path = p;
# 2850 "../Middlewares/FATFS/source/ff.c"
 while (di) {
  wc = lfn[di - 1];
  if (wc != ' ' && wc != '.') break;
  di--;
 }
 lfn[di] = 0;
 if (di == 0) return FR_INVALID_NAME;


 for (si = 0; lfn[si] == ' '; si++) ;
 if (si > 0 || lfn[si] == '.') cf |= 0x01 | 0x02;
 while (di > 0 && lfn[di - 1] != '.') di--;

 memset(dp->fn, ' ', 11);
 i = b = 0; ni = 8;
 for (;;) {
  wc = lfn[si++];
  if (wc == 0) break;
  if (wc == ' ' || (wc == '.' && si != di)) {
   cf |= 0x01 | 0x02;
   continue;
  }

  if (i >= ni || si == di) {
   if (ni == 11) {
    cf |= 0x01 | 0x02;
    break;
   }
   if (si != di) cf |= 0x01 | 0x02;
   if (si > di) break;
   si = di; i = 8; ni = 11; b <<= 2;
   continue;
  }

  if (wc >= 0x80) {
   cf |= 0x02;
# 2897 "../Middlewares/FATFS/source/ff.c"
   wc = ff_uni2oem(ff_wtoupper(wc), 936);

  }

  if (wc >= 0x100) {
   if (i >= ni - 1) {
    cf |= 0x01 | 0x02;
    i = ni; continue;
   }
   dp->fn[i++] = (BYTE)(wc >> 8);
  } else {
   if (wc == 0 || strchr("+,;=[]", (int)wc)) {
    wc = '_'; cf |= 0x01 | 0x02;
   } else {
    if (((wc) >= 'A' && (wc) <= 'Z')) {
     b |= 2;
    }
    if (((wc) >= 'a' && (wc) <= 'z')) {
     b |= 1; wc -= 0x20;
    }
   }
  }
  dp->fn[i++] = (BYTE)wc;
 }

 if (dp->fn[0] == 0xE5) dp->fn[0] = 0x05;

 if (ni == 8) b <<= 2;
 if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= 0x02;
 if (!(cf & 0x02)) {
  if (b & 0x01) cf |= 0x10;
  if (b & 0x04) cf |= 0x08;
 }

 dp->fn[11] = cf;

 return FR_OK;
# 2998 "../Middlewares/FATFS/source/ff.c"
}
# 3007 "../Middlewares/FATFS/source/ff.c"
static FRESULT follow_path (
 DIR* dp,
 const TCHAR* path
)
{
 FRESULT res;
 BYTE ns;
 FATFS *fs = dp->obj.fs;







 {
  while (((*path) == '/' || (*path) == '\\')) path++;
  dp->obj.sclust = 0;
 }

 dp->obj.n_frag = 0;
# 3043 "../Middlewares/FATFS/source/ff.c"
 if ((UINT)*path < ' ') {
  dp->fn[11] = 0x80;
  res = dir_sdi(dp, 0);

 } else {
  for (;;) {
   res = create_name(dp, &path);
   if (res != FR_OK) break;
   res = dir_find(dp);
   ns = dp->fn[11];
   if (res != FR_OK) {
    if (res == FR_NO_FILE) {
     if (0 && (ns & 0x20)) {
      if (!(ns & 0x04)) continue;
      dp->fn[11] = 0x80;
      res = FR_OK;
     } else {
      if (!(ns & 0x04)) res = FR_NO_PATH;
     }
    }
    break;
   }
   if (ns & 0x04) break;

   if (!(dp->obj.attr & 0x10)) {
    res = FR_NO_PATH; break;
   }

   if (fs->fs_type == 4) {
    dp->obj.c_scl = dp->obj.sclust;
    dp->obj.c_size = ((DWORD)dp->obj.objsize & 0xFFFFFF00) | dp->obj.stat;
    dp->obj.c_ofs = dp->blk_ofs;
    init_alloc_info(fs, &dp->obj);
   } else

   {
    dp->obj.sclust = ld_clust(fs, fs->win + dp->dptr % ((UINT)512));
   }
  }
 }

 return res;
}
# 3094 "../Middlewares/FATFS/source/ff.c"
static int get_ldnumber (
 const TCHAR** path
)
{
 const TCHAR *tp, *tt;
 TCHAR tc;
 int i;
 int vol = -1;





 tt = tp = *path;
 if (!tp) return vol;
 do tc = *tt++; while (!((UINT)(tc) < (3 ? ' ' : '!')) && tc != ':');

 if (tc == ':') {
  i = 2;
  if (((*tp) >= '0' && (*tp) <= '9') && tp + 2 == tt) {
   i = (int)*tp - '0';
  }
# 3129 "../Middlewares/FATFS/source/ff.c"
  if (i < 2) {
   vol = i;
   *path = tt;
  }
  return vol;
 }
# 3158 "../Middlewares/FATFS/source/ff.c"
 vol = 0;

 return vol;
}
# 3242 "../Middlewares/FATFS/source/ff.c"
static UINT check_fs (
 FATFS* fs,
 LBA_t sect
)
{
 WORD w, sign;
 BYTE b;


 fs->wflag = 0; fs->winsect = (LBA_t)0 - 1;
 if (move_window(fs, sect) != FR_OK) return 4;
 sign = ld_word(fs->win + 510);

 if (sign == 0xAA55 && !memcmp(fs->win + 0, "\xEB\x76\x90" "EXFAT   ", 11)) return 1;

 b = fs->win[0];
 if (b == 0xEB || b == 0xE9 || b == 0xE8) {
  if (sign == 0xAA55 && !memcmp(fs->win + 82, "FAT32   ", 8)) {
   return 0;
  }

  w = ld_word(fs->win + 11);
  b = fs->win[13];
  if ((w & (w - 1)) == 0 && w >= 512 && w <= 512
   && b != 0 && (b & (b - 1)) == 0
   && ld_word(fs->win + 14) != 0
   && (UINT)fs->win[16] - 1 <= 1
   && ld_word(fs->win + 17) != 0
   && (ld_word(fs->win + 19) >= 128 || ld_dword(fs->win + 32) >= 0x10000)
   && ld_word(fs->win + 22) != 0) {
    return 0;
  }
 }
 return sign == 0xAA55 ? 2 : 3;
}





static UINT find_volume (
 FATFS* fs,
 UINT part
)
{
 UINT fmt, i;
 DWORD mbr_pt[4];


 fmt = check_fs(fs, 0);
 if (fmt != 2 && (fmt >= 3 || part == 0)) return fmt;
# 3318 "../Middlewares/FATFS/source/ff.c"
 if (0 && part > 4) return 3;
 for (i = 0; i < 4; i++) {
  mbr_pt[i] = ld_dword(fs->win + 446 + i * 16 + 8);
 }
 i = part ? part - 1 : 0;
 do {
  fmt = mbr_pt[i] ? check_fs(fs, mbr_pt[i]) : 3;
 } while (part == 0 && fmt >= 2 && ++i < 4);
 return fmt;
}
# 3336 "../Middlewares/FATFS/source/ff.c"
static FRESULT mount_volume (
 const TCHAR** path,
 FATFS** rfs,
 BYTE mode
)
{
 int vol;
 DSTATUS stat;
 LBA_t bsect;
 DWORD tsect, sysect, fasize, nclst, szbfat;
 WORD nrsv;
 FATFS *fs;
 UINT fmt;



 *rfs = 0;
 vol = get_ldnumber(path);
 if (vol < 0) return FR_INVALID_DRIVE;


 fs = FatFs[vol];
 if (!fs) return FR_NOT_ENABLED;



 { };

 *rfs = fs;

 mode &= (BYTE)~0x01;
 if (fs->fs_type != 0) {
  stat = disk_status(fs->pdrv);
  if (!(stat & 0x01)) {
   if (!0 && mode && (stat & 0x04)) {
    return FR_WRITE_PROTECTED;
   }
   return FR_OK;
  }
 }




 fs->fs_type = 0;
 fs->pdrv = (BYTE)(vol);
 stat = disk_initialize(fs->pdrv);
 if (stat & 0x01) {
  return FR_NOT_READY;
 }
 if (!0 && mode && (stat & 0x04)) {
  return FR_WRITE_PROTECTED;
 }






 fmt = find_volume(fs, 0);
 if (fmt == 4) return FR_DISK_ERR;
 if (fmt >= 2) return FR_NO_FILESYSTEM;
 bsect = fs->winsect;




 if (fmt == 1) {
  QWORD maxlba;
  DWORD so, cv, bcl, i;

  for (i = 11; i < 11 + 53 && fs->win[i] == 0; i++) ;
  if (i < 11 + 53) return FR_NO_FILESYSTEM;

  if (ld_word(fs->win + 104) != 0x100) return FR_NO_FILESYSTEM;

  if (1 << fs->win[108] != ((UINT)512)) {
   return FR_NO_FILESYSTEM;
  }

  maxlba = ld_qword(fs->win + 72) + bsect;
  if (!0 && maxlba >= 0x100000000) return FR_NO_FILESYSTEM;

  fs->fsize = ld_dword(fs->win + 84);

  fs->n_fats = fs->win[110];
  if (fs->n_fats != 1) return FR_NO_FILESYSTEM;

  fs->csize = 1 << fs->win[109];
  if (fs->csize == 0) return FR_NO_FILESYSTEM;

  nclst = ld_dword(fs->win + 92);
  if (nclst > 0x7FFFFFFD) return FR_NO_FILESYSTEM;
  fs->n_fatent = nclst + 2;


  fs->volbase = bsect;
  fs->database = bsect + ld_dword(fs->win + 88);
  fs->fatbase = bsect + ld_dword(fs->win + 80);
  if (maxlba < (QWORD)fs->database + nclst * fs->csize) return FR_NO_FILESYSTEM;
  fs->dirbase = ld_dword(fs->win + 96);


  so = i = 0;
  for (;;) {
   if (i == 0) {
    if (so >= fs->csize) return FR_NO_FILESYSTEM;
    if (move_window(fs, clst2sect(fs, (DWORD)fs->dirbase) + so) != FR_OK) return FR_DISK_ERR;
    so++;
   }
   if (fs->win[i] == 0x81) break;
   i = (i + 32) % ((UINT)512);
  }
  bcl = ld_dword(fs->win + i + 20);
  if (bcl < 2 || bcl >= fs->n_fatent) return FR_NO_FILESYSTEM;
  fs->bitbase = fs->database + fs->csize * (bcl - 2);
  for (;;) {
   if (move_window(fs, fs->fatbase + bcl / (((UINT)512) / 4)) != FR_OK) return FR_DISK_ERR;
   cv = ld_dword(fs->win + bcl % (((UINT)512) / 4) * 4);
   if (cv == 0xFFFFFFFF) break;
   if (cv != ++bcl) return FR_NO_FILESYSTEM;
  }


  fs->last_clst = fs->free_clst = 0xFFFFFFFF;

  fmt = 4;
 } else

 {
  if (ld_word(fs->win + 11) != ((UINT)512)) return FR_NO_FILESYSTEM;

  fasize = ld_word(fs->win + 22);
  if (fasize == 0) fasize = ld_dword(fs->win + 36);
  fs->fsize = fasize;

  fs->n_fats = fs->win[16];
  if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;
  fasize *= fs->n_fats;

  fs->csize = fs->win[13];
  if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;

  fs->n_rootdir = ld_word(fs->win + 17);
  if (fs->n_rootdir % (((UINT)512) / 32)) return FR_NO_FILESYSTEM;

  tsect = ld_word(fs->win + 19);
  if (tsect == 0) tsect = ld_dword(fs->win + 32);

  nrsv = ld_word(fs->win + 14);
  if (nrsv == 0) return FR_NO_FILESYSTEM;


  sysect = nrsv + fasize + fs->n_rootdir / (((UINT)512) / 32);
  if (tsect < sysect) return FR_NO_FILESYSTEM;
  nclst = (tsect - sysect) / fs->csize;
  if (nclst == 0) return FR_NO_FILESYSTEM;
  fmt = 0;
  if (nclst <= 0x0FFFFFF5) fmt = 3;
  if (nclst <= 0xFFF5) fmt = 2;
  if (nclst <= 0xFF5) fmt = 1;
  if (fmt == 0) return FR_NO_FILESYSTEM;


  fs->n_fatent = nclst + 2;
  fs->volbase = bsect;
  fs->fatbase = bsect + nrsv;
  fs->database = bsect + sysect;
  if (fmt == 3) {
   if (ld_word(fs->win + 42) != 0) return FR_NO_FILESYSTEM;
   if (fs->n_rootdir != 0) return FR_NO_FILESYSTEM;
   fs->dirbase = ld_dword(fs->win + 44);
   szbfat = fs->n_fatent * 4;
  } else {
   if (fs->n_rootdir == 0) return FR_NO_FILESYSTEM;
   fs->dirbase = fs->fatbase + fasize;
   szbfat = (fmt == 2) ?
    fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
  }
  if (fs->fsize < (szbfat + (((UINT)512) - 1)) / ((UINT)512)) return FR_NO_FILESYSTEM;



  fs->last_clst = fs->free_clst = 0xFFFFFFFF;
  fs->fsi_flag = 0x80;

  if (fmt == 3
   && ld_word(fs->win + 48) == 1
   && move_window(fs, bsect + 1) == FR_OK)
  {
   fs->fsi_flag = 0;
   if (ld_word(fs->win + 510) == 0xAA55
    && ld_dword(fs->win + 0) == 0x41615252
    && ld_dword(fs->win + 484) == 0x61417272)
   {

    fs->free_clst = ld_dword(fs->win + 488);


    fs->last_clst = ld_dword(fs->win + 492);

   }
  }


 }

 fs->fs_type = (BYTE)fmt;
 fs->id = ++Fsid;
# 3557 "../Middlewares/FATFS/source/ff.c"
 return FR_OK;
}
# 3567 "../Middlewares/FATFS/source/ff.c"
static FRESULT validate (
 FFOBJID* obj,
 FATFS** rfs
)
{
 FRESULT res = FR_INVALID_OBJECT;


 if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {
# 3587 "../Middlewares/FATFS/source/ff.c"
  if (!(disk_status(obj->fs->pdrv) & 0x01)) {
   { };
   res = FR_OK;
  }

 }
 *rfs = (res == FR_OK) ? obj->fs : 0;
 return res;
}
# 3612 "../Middlewares/FATFS/source/ff.c"
FRESULT f_mount (
 FATFS* fs,
 const TCHAR* path,
 BYTE opt
)
{
 FATFS *cfs;
 int vol;
 FRESULT res;
 const TCHAR *rp = path;



 vol = get_ldnumber(&rp);
 if (vol < 0) return FR_INVALID_DRIVE;
 cfs = FatFs[vol];

 if (cfs) {






  cfs->fs_type = 0;
 }

 if (fs) {
  fs->fs_type = 0;



 }
 FatFs[vol] = fs;

 if (opt == 0) return FR_OK;

 res = mount_volume(&path, &fs, 0);
 return res;
}
# 3660 "../Middlewares/FATFS/source/ff.c"
FRESULT f_open (
 FIL* fp,
 const TCHAR* path,
 BYTE mode
)
{
 FRESULT res;
 DIR dj;
 FATFS *fs;

 DWORD cl, bcs, clst, tm;
 LBA_t sc;
 FSIZE_t ofs;

 WCHAR *lfn;


 if (!fp) return FR_INVALID_OBJECT;


 mode &= 0 ? 0x01 : 0x01 | 0x02 | 0x08 | 0x04 | 0x10 | 0x30;
 res = mount_volume(&path, &fs, mode);
 if (res == FR_OK) {
  dj.obj.fs = fs;
  { lfn = ff_memalloc((255 +1)*2 + ((255 + 44U) / 15 * 32)); if (!lfn) return FR_NOT_ENOUGH_CORE; (fs)->lfnbuf = lfn; (fs)->dirbuf = (BYTE*)(lfn+255 +1); };
  res = follow_path(&dj, path);

  if (res == FR_OK) {
   if (dj.fn[11] & 0x80) {
    res = FR_INVALID_NAME;
   }





  }

  if (mode & (0x08 | 0x10 | 0x04)) {
   if (res != FR_OK) {
    if (res == FR_NO_FILE) {



     res = dir_register(&dj);

    }
    mode |= 0x08;
   }
   else {
    if (dj.obj.attr & (0x01 | 0x10)) {
     res = FR_DENIED;
    } else {
     if (mode & 0x04) res = FR_EXIST;
    }
   }
   if (res == FR_OK && (mode & 0x08)) {

    if (fs->fs_type == 4) {

     fp->obj.fs = fs;
     init_alloc_info(fs, &fp->obj);

     memset(fs->dirbuf + 2, 0, 30);
     memset(fs->dirbuf + 38, 0, 26);
     fs->dirbuf[4] = 0x20;
     st_dword(fs->dirbuf + 8, get_fattime());
     fs->dirbuf[33] = 1;
     res = store_xdir(&dj);
     if (res == FR_OK && fp->obj.sclust != 0) {
      res = remove_chain(&fp->obj, fp->obj.sclust, 0);
      fs->last_clst = fp->obj.sclust - 1;
     }
    } else

    {

     tm = get_fattime();
     st_dword(dj.dir + 14, tm);
     st_dword(dj.dir + 22, tm);
     cl = ld_clust(fs, dj.dir);
     dj.dir[11] = 0x20;
     st_clust(fs, dj.dir, 0);
     st_dword(dj.dir + 28, 0);
     fs->wflag = 1;
     if (cl != 0) {
      sc = fs->winsect;
      res = remove_chain(&dj.obj, cl, 0);
      if (res == FR_OK) {
       res = move_window(fs, sc);
       fs->last_clst = cl - 1;
      }
     }
    }
   }
  }
  else {
   if (res == FR_OK) {
    if (dj.obj.attr & 0x10) {
     res = FR_NO_FILE;
    } else {
     if ((mode & 0x02) && (dj.obj.attr & 0x01)) {
      res = FR_DENIED;
     }
    }
   }
  }
  if (res == FR_OK) {
   if (mode & 0x08) mode |= 0x40;
   fp->dir_sect = fs->winsect;
   fp->dir_ptr = dj.dir;




  }
# 3788 "../Middlewares/FATFS/source/ff.c"
  if (res == FR_OK) {

   if (fs->fs_type == 4) {
    fp->obj.c_scl = dj.obj.sclust;
    fp->obj.c_size = ((DWORD)dj.obj.objsize & 0xFFFFFF00) | dj.obj.stat;
    fp->obj.c_ofs = dj.blk_ofs;
    init_alloc_info(fs, &fp->obj);
   } else

   {
    fp->obj.sclust = ld_clust(fs, dj.dir);
    fp->obj.objsize = ld_dword(dj.dir + 28);
   }

   fp->cltbl = 0;

   fp->obj.fs = fs;
   fp->obj.id = fs->id;
   fp->flag = mode;
   fp->err = 0;
   fp->sect = 0;
   fp->fptr = 0;


   memset(fp->buf, 0, sizeof fp->buf);

   if ((mode & 0x20) && fp->obj.objsize > 0) {
    fp->fptr = fp->obj.objsize;
    bcs = (DWORD)fs->csize * ((UINT)512);
    clst = fp->obj.sclust;
    for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
     clst = get_fat(&fp->obj, clst);
     if (clst <= 1) res = FR_INT_ERR;
     if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
    }
    fp->clust = clst;
    if (res == FR_OK && ofs % ((UINT)512)) {
     sc = clst2sect(fs, clst);
     if (sc == 0) {
      res = FR_INT_ERR;
     } else {
      fp->sect = sc + (DWORD)(ofs / ((UINT)512));

      if (disk_read(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;

     }
    }



   }

  }

  ff_memfree(lfn);
 }

 if (res != FR_OK) fp->obj.fs = 0;

 return res;
}
# 3857 "../Middlewares/FATFS/source/ff.c"
FRESULT f_read (
 FIL* fp,
 void* buff,
 UINT btr,
 UINT* br
)
{
 FRESULT res;
 FATFS *fs;
 DWORD clst;
 LBA_t sect;
 FSIZE_t remain;
 UINT rcnt, cc, csect;
 BYTE *rbuff = (BYTE*)buff;


 *br = 0;
 res = validate(&fp->obj, &fs);
 if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) return res;
 if (!(fp->flag & 0x01)) return FR_DENIED;
 remain = fp->obj.objsize - fp->fptr;
 if (btr > remain) btr = (UINT)remain;

 for ( ; btr > 0; btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {
  if (fp->fptr % ((UINT)512) == 0) {
   csect = (UINT)(fp->fptr / ((UINT)512) & (fs->csize - 1));
   if (csect == 0) {
    if (fp->fptr == 0) {
     clst = fp->obj.sclust;
    } else {

     if (fp->cltbl) {
      clst = clmt_clust(fp, fp->fptr);
     } else

     {
      clst = get_fat(&fp->obj, fp->clust);
     }
    }
    if (clst < 2) { fp->err = (BYTE)(FR_INT_ERR); return FR_INT_ERR; };
    if (clst == 0xFFFFFFFF) { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
    fp->clust = clst;
   }
   sect = clst2sect(fs, fp->clust);
   if (sect == 0) { fp->err = (BYTE)(FR_INT_ERR); return FR_INT_ERR; };
   sect += csect;
   cc = btr / ((UINT)512);
   if (cc > 0) {
    if (csect + cc > fs->csize) {
     cc = fs->csize - csect;
    }
    if (disk_read(fs->pdrv, rbuff, sect, cc) != RES_OK) { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };






    if ((fp->flag & 0x80) && fp->sect - sect < cc) {
     memcpy(rbuff + ((fp->sect - sect) * ((UINT)512)), fp->buf, ((UINT)512));
    }


    rcnt = ((UINT)512) * cc;
    continue;
   }

   if (fp->sect != sect) {

    if (fp->flag & 0x80) {
     if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
     fp->flag &= (BYTE)~0x80;
    }

    if (disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK) { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
   }

   fp->sect = sect;
  }
  rcnt = ((UINT)512) - (UINT)fp->fptr % ((UINT)512);
  if (rcnt > btr) rcnt = btr;




  memcpy(rbuff, fp->buf + fp->fptr % ((UINT)512), rcnt);

 }

 return FR_OK;
}
# 3957 "../Middlewares/FATFS/source/ff.c"
FRESULT f_write (
 FIL* fp,
 const void* buff,
 UINT btw,
 UINT* bw
)
{
 FRESULT res;
 FATFS *fs;
 DWORD clst;
 LBA_t sect;
 UINT wcnt, cc, csect;
 const BYTE *wbuff = (const BYTE*)buff;


 *bw = 0;
 res = validate(&fp->obj, &fs);
 if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) return res;
 if (!(fp->flag & 0x02)) return FR_DENIED;


 if ((!1 || fs->fs_type != 4) && (DWORD)(fp->fptr + btw) < (DWORD)fp->fptr) {
  btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
 }

 for ( ; btw > 0; btw -= wcnt, *bw += wcnt, wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize) {
  if (fp->fptr % ((UINT)512) == 0) {
   csect = (UINT)(fp->fptr / ((UINT)512)) & (fs->csize - 1);
   if (csect == 0) {
    if (fp->fptr == 0) {
     clst = fp->obj.sclust;
     if (clst == 0) {
      clst = create_chain(&fp->obj, 0);
     }
    } else {

     if (fp->cltbl) {
      clst = clmt_clust(fp, fp->fptr);
     } else

     {
      clst = create_chain(&fp->obj, fp->clust);
     }
    }
    if (clst == 0) break;
    if (clst == 1) { fp->err = (BYTE)(FR_INT_ERR); return FR_INT_ERR; };
    if (clst == 0xFFFFFFFF) { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
    fp->clust = clst;
    if (fp->obj.sclust == 0) fp->obj.sclust = clst;
   }



   if (fp->flag & 0x80) {
    if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
    fp->flag &= (BYTE)~0x80;
   }

   sect = clst2sect(fs, fp->clust);
   if (sect == 0) { fp->err = (BYTE)(FR_INT_ERR); return FR_INT_ERR; };
   sect += csect;
   cc = btw / ((UINT)512);
   if (cc > 0) {
    if (csect + cc > fs->csize) {
     cc = fs->csize - csect;
    }
    if (disk_write(fs->pdrv, wbuff, sect, cc) != RES_OK) { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };







    if (fp->sect - sect < cc) {
     memcpy(fp->buf, wbuff + ((fp->sect - sect) * ((UINT)512)), ((UINT)512));
     fp->flag &= (BYTE)~0x80;
    }


    wcnt = ((UINT)512) * cc;
    continue;
   }






   if (fp->sect != sect &&
    fp->fptr < fp->obj.objsize &&
    disk_read(fs->pdrv, fp->buf, sect, 1) != RES_OK) {
     { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
   }

   fp->sect = sect;
  }
  wcnt = ((UINT)512) - (UINT)fp->fptr % ((UINT)512);
  if (wcnt > btw) wcnt = btw;





  memcpy(fp->buf + fp->fptr % ((UINT)512), wbuff, wcnt);
  fp->flag |= 0x80;

 }

 fp->flag |= 0x40;

 return FR_OK;
}
# 4078 "../Middlewares/FATFS/source/ff.c"
FRESULT f_sync (
 FIL* fp
)
{
 FRESULT res;
 FATFS *fs;
 DWORD tm;
 BYTE *dir;


 res = validate(&fp->obj, &fs);
 if (res == FR_OK) {
  if (fp->flag & 0x40) {

   if (fp->flag & 0x80) {
    if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) return FR_DISK_ERR;
    fp->flag &= (BYTE)~0x80;
   }


   tm = get_fattime();

   if (fs->fs_type == 4) {
    res = fill_first_frag(&fp->obj);
    if (res == FR_OK) {
     res = fill_last_frag(&fp->obj, fp->clust, 0xFFFFFFFF);
    }
    if (res == FR_OK) {
     DIR dj;
     WCHAR *lfn;

     { lfn = ff_memalloc((255 +1)*2 + ((255 + 44U) / 15 * 32)); if (!lfn) return FR_NOT_ENOUGH_CORE; (fs)->lfnbuf = lfn; (fs)->dirbuf = (BYTE*)(lfn+255 +1); };
     res = load_obj_xdir(&dj, &fp->obj);
     if (res == FR_OK) {
      fs->dirbuf[4] |= 0x20;
      fs->dirbuf[33] = fp->obj.stat | 1;
      st_dword(fs->dirbuf + 52, fp->obj.sclust);
      st_qword(fs->dirbuf + 56, fp->obj.objsize);
      st_qword(fs->dirbuf + 40, fp->obj.objsize);
      st_dword(fs->dirbuf + 12, tm);
      fs->dirbuf[21] = 0;
      st_dword(fs->dirbuf + 16, 0);
      res = store_xdir(&dj);
      if (res == FR_OK) {
       res = sync_fs(fs);
       fp->flag &= (BYTE)~0x40;
      }
     }
     ff_memfree(lfn);
    }
   } else

   {
    res = move_window(fs, fp->dir_sect);
    if (res == FR_OK) {
     dir = fp->dir_ptr;
     dir[11] |= 0x20;
     st_clust(fp->obj.fs, dir, fp->obj.sclust);
     st_dword(dir + 28, (DWORD)fp->obj.objsize);
     st_dword(dir + 22, tm);
     st_word(dir + 18, 0);
     fs->wflag = 1;
     res = sync_fs(fs);
     fp->flag &= (BYTE)~0x40;
    }
   }
  }
 }

 return res;
}
# 4159 "../Middlewares/FATFS/source/ff.c"
FRESULT f_close (
 FIL* fp
)
{
 FRESULT res;
 FATFS *fs;


 res = f_sync(fp);
 if (res == FR_OK)

 {
  res = validate(&fp->obj, &fs);
  if (res == FR_OK) {




   fp->obj.fs = 0;




            return res;
  }
 }
 return res;
}
# 4375 "../Middlewares/FATFS/source/ff.c"
FRESULT f_lseek (
 FIL* fp,
 FSIZE_t ofs
)
{
 FRESULT res;
 FATFS *fs;
 DWORD clst, bcs;
 LBA_t nsect;
 FSIZE_t ifptr;

 DWORD cl, pcl, ncl, tcl, tlen, ulen;
 DWORD *tbl;
 LBA_t dsc;


 res = validate(&fp->obj, &fs);
 if (res == FR_OK) res = (FRESULT)fp->err;

 if (res == FR_OK && fs->fs_type == 4) {
  res = fill_last_frag(&fp->obj, fp->clust, 0xFFFFFFFF);
 }

 if (res != FR_OK) return res;


 if (fp->cltbl) {
  if (ofs == ((FSIZE_t)0 - 1)) {
   tbl = fp->cltbl;
   tlen = *tbl++; ulen = 2;
   cl = fp->obj.sclust;
   if (cl != 0) {
    do {

     tcl = cl; ncl = 0; ulen += 2;
     do {
      pcl = cl; ncl++;
      cl = get_fat(&fp->obj, cl);
      if (cl <= 1) { fp->err = (BYTE)(FR_INT_ERR); return FR_INT_ERR; };
      if (cl == 0xFFFFFFFF) { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
     } while (cl == pcl + 1);
     if (ulen <= tlen) {
      *tbl++ = ncl; *tbl++ = tcl;
     }
    } while (cl < fs->n_fatent);
   }
   *fp->cltbl = ulen;
   if (ulen <= tlen) {
    *tbl = 0;
   } else {
    res = FR_NOT_ENOUGH_CORE;
   }
  } else {
   if (ofs > fp->obj.objsize) ofs = fp->obj.objsize;
   fp->fptr = ofs;
   if (ofs > 0) {
    fp->clust = clmt_clust(fp, ofs - 1);
    dsc = clst2sect(fs, fp->clust);
    if (dsc == 0) { fp->err = (BYTE)(FR_INT_ERR); return FR_INT_ERR; };
    dsc += (DWORD)((ofs - 1) / ((UINT)512)) & (fs->csize - 1);
    if (fp->fptr % ((UINT)512) && dsc != fp->sect) {


     if (fp->flag & 0x80) {
      if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
      fp->flag &= (BYTE)~0x80;
     }

     if (disk_read(fs->pdrv, fp->buf, dsc, 1) != RES_OK) { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };

     fp->sect = dsc;
    }
   }
  }
 } else



 {

  if (fs->fs_type != 4 && ofs >= 0x100000000) ofs = 0xFFFFFFFF;

  if (ofs > fp->obj.objsize && (0 || !(fp->flag & 0x02))) {
   ofs = fp->obj.objsize;
  }
  ifptr = fp->fptr;
  fp->fptr = nsect = 0;
  if (ofs > 0) {
   bcs = (DWORD)fs->csize * ((UINT)512);
   if (ifptr > 0 &&
    (ofs - 1) / bcs >= (ifptr - 1) / bcs) {
    fp->fptr = (ifptr - 1) & ~(FSIZE_t)(bcs - 1);
    ofs -= fp->fptr;
    clst = fp->clust;
   } else {
    clst = fp->obj.sclust;

    if (clst == 0) {
     clst = create_chain(&fp->obj, 0);
     if (clst == 1) { fp->err = (BYTE)(FR_INT_ERR); return FR_INT_ERR; };
     if (clst == 0xFFFFFFFF) { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
     fp->obj.sclust = clst;
    }

    fp->clust = clst;
   }
   if (clst != 0) {
    while (ofs > bcs) {
     ofs -= bcs; fp->fptr += bcs;

     if (fp->flag & 0x02) {
      if (1 && fp->fptr > fp->obj.objsize) {
       fp->obj.objsize = fp->fptr;
       fp->flag |= 0x40;
      }
      clst = create_chain(&fp->obj, clst);
      if (clst == 0) {
       ofs = 0; break;
      }
     } else

     {
      clst = get_fat(&fp->obj, clst);
     }
     if (clst == 0xFFFFFFFF) { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
     if (clst <= 1 || clst >= fs->n_fatent) { fp->err = (BYTE)(FR_INT_ERR); return FR_INT_ERR; };
     fp->clust = clst;
    }
    fp->fptr += ofs;
    if (ofs % ((UINT)512)) {
     nsect = clst2sect(fs, clst);
     if (nsect == 0) { fp->err = (BYTE)(FR_INT_ERR); return FR_INT_ERR; };
     nsect += (DWORD)(ofs / ((UINT)512));
    }
   }
  }
  if (!0 && fp->fptr > fp->obj.objsize) {
   fp->obj.objsize = fp->fptr;
   fp->flag |= 0x40;
  }
  if (fp->fptr % ((UINT)512) && nsect != fp->sect) {


   if (fp->flag & 0x80) {
    if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };
    fp->flag &= (BYTE)~0x80;
   }

   if (disk_read(fs->pdrv, fp->buf, nsect, 1) != RES_OK) { fp->err = (BYTE)(FR_DISK_ERR); return FR_DISK_ERR; };

   fp->sect = nsect;
  }
 }

 return res;
}
# 4539 "../Middlewares/FATFS/source/ff.c"
FRESULT f_opendir (
 DIR* dp,
 const TCHAR* path
)
{
 FRESULT res;
 FATFS *fs;
 WCHAR *lfn;


 if (!dp) return FR_INVALID_OBJECT;


 res = mount_volume(&path, &fs, 0);
 if (res == FR_OK) {
  dp->obj.fs = fs;
  { lfn = ff_memalloc((255 +1)*2 + ((255 + 44U) / 15 * 32)); if (!lfn) return FR_NOT_ENOUGH_CORE; (fs)->lfnbuf = lfn; (fs)->dirbuf = (BYTE*)(lfn+255 +1); };
  res = follow_path(dp, path);
  if (res == FR_OK) {
   if (!(dp->fn[11] & 0x80)) {
    if (dp->obj.attr & 0x10) {

     if (fs->fs_type == 4) {
      dp->obj.c_scl = dp->obj.sclust;
      dp->obj.c_size = ((DWORD)dp->obj.objsize & 0xFFFFFF00) | dp->obj.stat;
      dp->obj.c_ofs = dp->blk_ofs;
      init_alloc_info(fs, &dp->obj);
     } else

     {
      dp->obj.sclust = ld_clust(fs, dp->dir);
     }
    } else {
     res = FR_NO_PATH;
    }
   }
   if (res == FR_OK) {
    dp->obj.id = fs->id;
    res = dir_sdi(dp, 0);
# 4588 "../Middlewares/FATFS/source/ff.c"
   }
  }
  ff_memfree(lfn);
  if (res == FR_NO_FILE) res = FR_NO_PATH;
 }
 if (res != FR_OK) dp->obj.fs = 0;

 return res;
}
# 4605 "../Middlewares/FATFS/source/ff.c"
FRESULT f_closedir (
 DIR *dp
)
{
 FRESULT res;
 FATFS *fs;


 res = validate(&dp->obj, &fs);
 if (res == FR_OK) {




  dp->obj.fs = 0;




 }
    return res;

}
# 4636 "../Middlewares/FATFS/source/ff.c"
FRESULT f_readdir (
 DIR* dp,
 FILINFO* fno
)
{
 FRESULT res;
 FATFS *fs;
 WCHAR *lfn;


 res = validate(&dp->obj, &fs);
 if (res == FR_OK) {
  if (!fno) {
   res = dir_sdi(dp, 0);
  } else {
   { lfn = ff_memalloc((255 +1)*2 + ((255 + 44U) / 15 * 32)); if (!lfn) return FR_NOT_ENOUGH_CORE; (fs)->lfnbuf = lfn; (fs)->dirbuf = (BYTE*)(lfn+255 +1); };
   res = dir_read(dp, 0);
   if (res == FR_NO_FILE) res = FR_OK;
   if (res == FR_OK) {
    get_fileinfo(dp, fno);
    res = dir_next(dp, 0);
    if (res == FR_NO_FILE) res = FR_OK;
   }
   ff_memfree(lfn);
  }
 }
 return res;
}
# 4724 "../Middlewares/FATFS/source/ff.c"
FRESULT f_stat (
 const TCHAR* path,
 FILINFO* fno
)
{
 FRESULT res;
 DIR dj;
 WCHAR *lfn;



 res = mount_volume(&path, &dj.obj.fs, 0);
 if (res == FR_OK) {
  { lfn = ff_memalloc((255 +1)*2 + ((255 + 44U) / 15 * 32)); if (!lfn) return FR_NOT_ENOUGH_CORE; (dj.obj.fs)->lfnbuf = lfn; (dj.obj.fs)->dirbuf = (BYTE*)(lfn+255 +1); };
  res = follow_path(&dj, path);
  if (res == FR_OK) {
   if (dj.fn[11] & 0x80) {
    res = FR_INVALID_NAME;
   } else {
    if (fno) get_fileinfo(&dj, fno);
   }
  }
  ff_memfree(lfn);
 }

 return res;
}
# 4759 "../Middlewares/FATFS/source/ff.c"
FRESULT f_getfree (
 const TCHAR* path,
 DWORD* nclst,
 FATFS** fatfs
)
{
 FRESULT res;
 FATFS *fs;
 DWORD nfree, clst, stat;
 LBA_t sect;
 UINT i;
 FFOBJID obj;



 res = mount_volume(&path, &fs, 0);
 if (res == FR_OK) {
  *fatfs = fs;

  if (fs->free_clst <= fs->n_fatent - 2) {
   *nclst = fs->free_clst;
  } else {

   nfree = 0;
   if (fs->fs_type == 1) {
    clst = 2; obj.fs = fs;
    do {
     stat = get_fat(&obj, clst);
     if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
     if (stat == 1) { res = FR_INT_ERR; break; }
     if (stat == 0) nfree++;
    } while (++clst < fs->n_fatent);
   } else {

    if (fs->fs_type == 4) {
     BYTE bm;
     UINT b;

     clst = fs->n_fatent - 2;
     sect = fs->bitbase;
     i = 0;
     do {
      if (i == 0) {
       res = move_window(fs, sect++);
       if (res != FR_OK) break;
      }
      for (b = 8, bm = fs->win[i]; b && clst; b--, clst--) {
       if (!(bm & 1)) nfree++;
       bm >>= 1;
      }
      i = (i + 1) % ((UINT)512);
     } while (clst);
    } else

    {
     clst = fs->n_fatent;
     sect = fs->fatbase;
     i = 0;
     do {
      if (i == 0) {
       res = move_window(fs, sect++);
       if (res != FR_OK) break;
      }
      if (fs->fs_type == 2) {
       if (ld_word(fs->win + i) == 0) nfree++;
       i += 2;
      } else {
       if ((ld_dword(fs->win + i) & 0x0FFFFFFF) == 0) nfree++;
       i += 4;
      }
      i %= ((UINT)512);
     } while (--clst);
    }
   }
   if (res == FR_OK) {
    *nclst = nfree;
    fs->free_clst = nfree;
    fs->fsi_flag |= 1;
   }
  }
 }

 return res;
}
# 4851 "../Middlewares/FATFS/source/ff.c"
FRESULT f_truncate (
 FIL* fp
)
{
 FRESULT res;
 FATFS *fs;
 DWORD ncl;


 res = validate(&fp->obj, &fs);
 if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) return res;
 if (!(fp->flag & 0x02)) return FR_DENIED;

 if (fp->fptr < fp->obj.objsize) {
  if (fp->fptr == 0) {
   res = remove_chain(&fp->obj, fp->obj.sclust, 0);
   fp->obj.sclust = 0;
  } else {
   ncl = get_fat(&fp->obj, fp->clust);
   res = FR_OK;
   if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
   if (ncl == 1) res = FR_INT_ERR;
   if (res == FR_OK && ncl < fs->n_fatent) {
    res = remove_chain(&fp->obj, ncl, fp->clust);
   }
  }
  fp->obj.objsize = fp->fptr;
  fp->flag |= 0x40;

  if (res == FR_OK && (fp->flag & 0x80)) {
   if (disk_write(fs->pdrv, fp->buf, fp->sect, 1) != RES_OK) {
    res = FR_DISK_ERR;
   } else {
    fp->flag &= (BYTE)~0x80;
   }
  }

  if (res != FR_OK) { fp->err = (BYTE)(res); return res; };
 }

 return res;
}
# 4901 "../Middlewares/FATFS/source/ff.c"
FRESULT f_unlink (
 const TCHAR* path
)
{
 FRESULT res;
 DIR dj, sdj;
 DWORD dclst = 0;
 FATFS *fs;

 FFOBJID obj;

 WCHAR *lfn;



 res = mount_volume(&path, &fs, 0x02);
 if (res == FR_OK) {
  dj.obj.fs = fs;
  { lfn = ff_memalloc((255 +1)*2 + ((255 + 44U) / 15 * 32)); if (!lfn) return FR_NOT_ENOUGH_CORE; (fs)->lfnbuf = lfn; (fs)->dirbuf = (BYTE*)(lfn+255 +1); };
  res = follow_path(&dj, path);
  if (0 && res == FR_OK && (dj.fn[11] & 0x20)) {
   res = FR_INVALID_NAME;
  }



  if (res == FR_OK) {
   if (dj.fn[11] & 0x80) {
    res = FR_INVALID_NAME;
   } else {
    if (dj.obj.attr & 0x01) {
     res = FR_DENIED;
    }
   }
   if (res == FR_OK) {

    obj.fs = fs;
    if (fs->fs_type == 4) {
     init_alloc_info(fs, &obj);
     dclst = obj.sclust;
    } else

    {
     dclst = ld_clust(fs, dj.dir);
    }
    if (dj.obj.attr & 0x10) {





     {
      sdj.obj.fs = fs;
      sdj.obj.sclust = dclst;

      if (fs->fs_type == 4) {
       sdj.obj.objsize = obj.objsize;
       sdj.obj.stat = obj.stat;
      }

      res = dir_sdi(&sdj, 0);
      if (res == FR_OK) {
       res = dir_read(&sdj, 0);
       if (res == FR_OK) res = FR_DENIED;
       if (res == FR_NO_FILE) res = FR_OK;
      }
     }
    }
   }
   if (res == FR_OK) {
    res = dir_remove(&dj);
    if (res == FR_OK && dclst != 0) {

     res = remove_chain(&obj, dclst, 0);



    }
    if (res == FR_OK) res = sync_fs(fs);
   }
  }
  ff_memfree(lfn);
 }

 return res;
}
# 4995 "../Middlewares/FATFS/source/ff.c"
FRESULT f_mkdir (
 const TCHAR* path
)
{
 FRESULT res;
 DIR dj;
 FFOBJID sobj;
 FATFS *fs;
 DWORD dcl, pcl, tm;
 WCHAR *lfn;


 res = mount_volume(&path, &fs, 0x02);
 if (res == FR_OK) {
  dj.obj.fs = fs;
  { lfn = ff_memalloc((255 +1)*2 + ((255 + 44U) / 15 * 32)); if (!lfn) return FR_NOT_ENOUGH_CORE; (fs)->lfnbuf = lfn; (fs)->dirbuf = (BYTE*)(lfn+255 +1); };
  res = follow_path(&dj, path);
  if (res == FR_OK) res = FR_EXIST;
  if (0 && res == FR_NO_FILE && (dj.fn[11] & 0x20)) {
   res = FR_INVALID_NAME;
  }
  if (res == FR_NO_FILE) {
   sobj.fs = fs;
   dcl = create_chain(&sobj, 0);
   res = FR_OK;
   if (dcl == 0) res = FR_DENIED;
   if (dcl == 1) res = FR_INT_ERR;
   if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
   tm = get_fattime();
   if (res == FR_OK) {
    res = dir_clear(fs, dcl);
    if (res == FR_OK) {
     if (!1 || fs->fs_type != 4) {
      memset(fs->win + 0, ' ', 11);
      fs->win[0] = '.';
      fs->win[11] = 0x10;
      st_dword(fs->win + 22, tm);
      st_clust(fs, fs->win, dcl);
      memcpy(fs->win + 32, fs->win, 32);
      fs->win[32 + 1] = '.'; pcl = dj.obj.sclust;
      st_clust(fs, fs->win + 32, pcl);
      fs->wflag = 1;
     }
     res = dir_register(&dj);
    }
   }
   if (res == FR_OK) {

    if (fs->fs_type == 4) {
     st_dword(fs->dirbuf + 12, tm);
     st_dword(fs->dirbuf + 52, dcl);
     st_dword(fs->dirbuf + 56, (DWORD)fs->csize * ((UINT)512));
     st_dword(fs->dirbuf + 40, (DWORD)fs->csize * ((UINT)512));
     fs->dirbuf[33] = 3;
     fs->dirbuf[4] = 0x10;
     res = store_xdir(&dj);
    } else

    {
     st_dword(dj.dir + 22, tm);
     st_clust(fs, dj.dir, dcl);
     dj.dir[11] = 0x10;
     fs->wflag = 1;
    }
    if (res == FR_OK) {
     res = sync_fs(fs);
    }
   } else {
    remove_chain(&sobj, dcl, 0);
   }
  }
  ff_memfree(lfn);
 }

 return res;
}
# 5079 "../Middlewares/FATFS/source/ff.c"
FRESULT f_rename (
 const TCHAR* path_old,
 const TCHAR* path_new
)
{
 FRESULT res;
 DIR djo, djn;
 FATFS *fs;
 BYTE buf[1 ? 32 * 2 : 32], *dir;
 LBA_t sect;
 WCHAR *lfn;


 get_ldnumber(&path_new);
 res = mount_volume(&path_old, &fs, 0x02);
 if (res == FR_OK) {
  djo.obj.fs = fs;
  { lfn = ff_memalloc((255 +1)*2 + ((255 + 44U) / 15 * 32)); if (!lfn) return FR_NOT_ENOUGH_CORE; (fs)->lfnbuf = lfn; (fs)->dirbuf = (BYTE*)(lfn+255 +1); };
  res = follow_path(&djo, path_old);
  if (res == FR_OK && (djo.fn[11] & (0x20 | 0x80))) res = FR_INVALID_NAME;





  if (res == FR_OK) {

   if (fs->fs_type == 4) {
    BYTE nf, nn;
    WORD nh;

    memcpy(buf, fs->dirbuf, 32 * 2);
    memcpy(&djn, &djo, sizeof djo);
    res = follow_path(&djn, path_new);
    if (res == FR_OK) {
     res = (djn.obj.sclust == djo.obj.sclust && djn.dptr == djo.dptr) ? FR_NO_FILE : FR_EXIST;
    }
    if (res == FR_NO_FILE) {
     res = dir_register(&djn);
     if (res == FR_OK) {
      nf = fs->dirbuf[1]; nn = fs->dirbuf[35];
      nh = ld_word(fs->dirbuf + 36);
      memcpy(fs->dirbuf, buf, 32 * 2);
      fs->dirbuf[1] = nf; fs->dirbuf[35] = nn;
      st_word(fs->dirbuf + 36, nh);
      if (!(fs->dirbuf[4] & 0x10)) fs->dirbuf[4] |= 0x20;

      res = store_xdir(&djn);
     }
    }
   } else

   {
    memcpy(buf, djo.dir, 32);
    memcpy(&djn, &djo, sizeof (DIR));
    res = follow_path(&djn, path_new);
    if (res == FR_OK) {
     res = (djn.obj.sclust == djo.obj.sclust && djn.dptr == djo.dptr) ? FR_NO_FILE : FR_EXIST;
    }
    if (res == FR_NO_FILE) {
     res = dir_register(&djn);
     if (res == FR_OK) {
      dir = djn.dir;
      memcpy(dir + 13, buf + 13, 32 - 13);
      dir[11] = buf[11];
      if (!(dir[11] & 0x10)) dir[11] |= 0x20;
      fs->wflag = 1;
      if ((dir[11] & 0x10) && djo.obj.sclust != djn.obj.sclust) {
       sect = clst2sect(fs, ld_clust(fs, dir));
       if (sect == 0) {
        res = FR_INT_ERR;
       } else {

        res = move_window(fs, sect);
        dir = fs->win + 32 * 1;
        if (res == FR_OK && dir[1] == '.') {
         st_clust(fs, dir, djn.obj.sclust);
         fs->wflag = 1;
        }
       }
      }
     }
    }
   }
   if (res == FR_OK) {
    res = dir_remove(&djo);
    if (res == FR_OK) {
     res = sync_fs(fs);
    }
   }

  }
  ff_memfree(lfn);
 }

 return res;
}
# 5283 "../Middlewares/FATFS/source/ff.c"
FRESULT f_getlabel (
 const TCHAR* path,
 TCHAR* label,
 DWORD* vsn
)
{
 FRESULT res;
 DIR dj;
 FATFS *fs;
 UINT si, di;
 WCHAR wc;


 res = mount_volume(&path, &fs, 0);


 if (res == FR_OK && label) {
  dj.obj.fs = fs; dj.obj.sclust = 0;
  res = dir_sdi(&dj, 0);
  if (res == FR_OK) {
    res = dir_read(&dj, 1);
    if (res == FR_OK) {

    if (fs->fs_type == 4) {
     WCHAR hs;
     UINT nw;

     for (si = di = hs = 0; si < dj.dir[1]; si++) {
      wc = ld_word(dj.dir + 2 + si * 2);
      if (hs == 0 && ((wc) >= 0xD800 && (wc) <= 0xDFFF)) {
       hs = wc; continue;
      }
      nw = put_utf((DWORD)hs << 16 | wc, &label[di], 4);
      if (nw == 0) { di = 0; break; }
      di += nw;
      hs = 0;
     }
     if (hs != 0) di = 0;
     label[di] = 0;
    } else

    {
     si = di = 0;
     while (si < 11) {
      wc = dj.dir[si++];






      label[di++] = (TCHAR)wc;

     }
     do {
      label[di] = 0;
      if (di == 0) break;
     } while (label[--di] == ' ');
    }
   }
  }
  if (res == FR_NO_FILE) {
   label[0] = 0;
   res = FR_OK;
  }
 }


 if (res == FR_OK && vsn) {
  res = move_window(fs, fs->volbase);
  if (res == FR_OK) {
   switch (fs->fs_type) {
   case 4:
    di = 100;
    break;

   case 3:
    di = 67;
    break;

   default:
    di = 39;
   }
   *vsn = ld_dword(fs->win + di);
  }
 }

 return res;
}
# 5380 "../Middlewares/FATFS/source/ff.c"
FRESULT f_setlabel (
 const TCHAR* label
)
{
 FRESULT res;
 DIR dj;
 FATFS *fs;
 BYTE dirvn[22];
 UINT di;
 WCHAR wc;
 static const char badchr[18] = "+.,;=[]" "/*:<>|\\\"\?\x7F";

 DWORD dc;



 res = mount_volume(&label, &fs, 0x02);
 if (res != FR_OK) return res;


 if (fs->fs_type == 4) {
  memset(dirvn, 0, 22);
  di = 0;
  while ((UINT)*label >= ' ') {
   dc = tchar2uni(&label);
   if (dc >= 0x10000) {
    if (dc == 0xFFFFFFFF || di >= 10) {
     dc = 0;
    } else {
     st_word(dirvn + di * 2, (WCHAR)(dc >> 16)); di++;
    }
   }
   if (dc == 0 || strchr(&badchr[7], (int)dc) || di >= 11) {
    return FR_INVALID_NAME;
   }
   st_word(dirvn + di * 2, (WCHAR)dc); di++;
  }
 } else

 {
  memset(dirvn, ' ', 11);
  di = 0;
  while ((UINT)*label >= ' ') {

   dc = tchar2uni(&label);
   wc = (dc < 0x10000) ? ff_uni2oem(ff_wtoupper(dc), 936) : 0;
# 5436 "../Middlewares/FATFS/source/ff.c"
   if (wc == 0 || strchr(&badchr[0], (int)wc) || di >= (UINT)((wc >= 0x100) ? 10 : 11)) {
    return FR_INVALID_NAME;
   }
   if (wc >= 0x100) dirvn[di++] = (BYTE)(wc >> 8);
   dirvn[di++] = (BYTE)wc;
  }
  if (dirvn[0] == 0xE5) return FR_INVALID_NAME;
  while (di && dirvn[di - 1] == ' ') di--;
 }


 dj.obj.fs = fs; dj.obj.sclust = 0;
 res = dir_sdi(&dj, 0);
 if (res == FR_OK) {
  res = dir_read(&dj, 1);
  if (res == FR_OK) {
   if (1 && fs->fs_type == 4) {
    dj.dir[1] = (BYTE)di;
    memcpy(dj.dir + 2, dirvn, 22);
   } else {
    if (di != 0) {
     memcpy(dj.dir, dirvn, 11);
    } else {
     dj.dir[0] = 0xE5;
    }
   }
   fs->wflag = 1;
   res = sync_fs(fs);
  } else {
   if (res == FR_NO_FILE) {
    res = FR_OK;
    if (di != 0) {
     res = dir_alloc(&dj, 1);
     if (res == FR_OK) {
      memset(dj.dir, 0, 32);
      if (1 && fs->fs_type == 4) {
       dj.dir[0] = 0x83;
       dj.dir[1] = (BYTE)di;
       memcpy(dj.dir + 2, dirvn, 22);
      } else {
       dj.dir[11] = 0x08;
       memcpy(dj.dir, dirvn, 11);
      }
      fs->wflag = 1;
      res = sync_fs(fs);
     }
    }
   }
  }
 }

 return res;
}
# 5668 "../Middlewares/FATFS/source/ff.c"
static FRESULT create_partition (
 BYTE drv,
 const LBA_t plst[],
 BYTE sys,
 BYTE* buf
)
{
 UINT i, cy;
 LBA_t sz_drv;
 DWORD sz_drv32, nxt_alloc32, sz_part32;
 BYTE *pte;
 BYTE hd, n_hd, sc, n_sc;


 if (disk_ioctl(drv, 1, &sz_drv) != RES_OK) return FR_DISK_ERR;
# 5767 "../Middlewares/FATFS/source/ff.c"
 {
  sz_drv32 = (DWORD)sz_drv;
  n_sc = 63;
  for (n_hd = 8; n_hd != 0 && sz_drv32 / n_hd / n_sc > 1024; n_hd *= 2) ;
  if (n_hd == 0) n_hd = 255;

  memset(buf, 0, 512);
  pte = buf + 446;
  for (i = 0, nxt_alloc32 = n_sc; i < 4 && nxt_alloc32 != 0 && nxt_alloc32 < sz_drv32; i++, nxt_alloc32 += sz_part32) {
   sz_part32 = (DWORD)plst[i];
   if (sz_part32 <= 100) sz_part32 = (sz_part32 == 100) ? sz_drv32 : sz_drv32 / 100 * sz_part32;
   if (nxt_alloc32 + sz_part32 > sz_drv32 || nxt_alloc32 + sz_part32 < nxt_alloc32) sz_part32 = sz_drv32 - nxt_alloc32;
   if (sz_part32 == 0) break;

   st_dword(pte + 8, nxt_alloc32);
   st_dword(pte + 12, sz_part32);
   pte[4] = sys;

   cy = (UINT)(nxt_alloc32 / n_sc / n_hd);
   hd = (BYTE)(nxt_alloc32 / n_sc % n_hd);
   sc = (BYTE)(nxt_alloc32 % n_sc + 1);
   pte[1] = hd;
   pte[2] = (BYTE)((cy >> 2 & 0xC0) | sc);
   pte[3] = (BYTE)cy;

   cy = (UINT)((nxt_alloc32 + sz_part32 - 1) / n_sc / n_hd);
   hd = (BYTE)((nxt_alloc32 + sz_part32 - 1) / n_sc % n_hd);
   sc = (BYTE)((nxt_alloc32 + sz_part32 - 1) % n_sc + 1);
   pte[5] = hd;
   pte[6] = (BYTE)((cy >> 2 & 0xC0) | sc);
   pte[7] = (BYTE)cy;

   pte += 16;
  }

  st_word(buf + 510, 0xAA55);
  if (disk_write(drv, buf, 0, 1) != RES_OK) return FR_DISK_ERR;
 }

 return FR_OK;
}



FRESULT f_mkfs (
 const TCHAR* path,
 const MKFS_PARM* opt,
 void* work,
 UINT len
)
{
 static const WORD cst[] = {1, 4, 16, 64, 256, 512, 0};
 static const WORD cst32[] = {1, 2, 4, 8, 16, 32, 0};
 static const MKFS_PARM defopt = {0x07, 0, 0, 0, 0};
 BYTE fsopt, fsty, sys, *buf, *pte, pdrv, ipart;
 WORD ss;
 DWORD sz_buf, sz_blk, n_clst, pau, nsect, n, vsn;
 LBA_t sz_vol, b_vol, b_fat, b_data;
 LBA_t sect, lba[2];
 DWORD sz_rsv, sz_fat, sz_dir, sz_au;
 UINT n_fat, n_root, i;
 int vol;
 DSTATUS ds;
 FRESULT fr;



 vol = get_ldnumber(&path);
 if (vol < 0) return FR_INVALID_DRIVE;
 if (FatFs[vol]) FatFs[vol]->fs_type = 0;
 pdrv = (BYTE)(vol);
 ipart = 0;
 if (!opt) opt = &defopt;


 ds = disk_initialize(pdrv);
 if (ds & 0x01) return FR_NOT_READY;
 if (ds & 0x04) return FR_WRITE_PROTECTED;
 sz_blk = opt->align;
 if (sz_blk == 0 && disk_ioctl(pdrv, 3, &sz_blk) != RES_OK) sz_blk = 1;
  if (sz_blk == 0 || sz_blk > 0x8000 || (sz_blk & (sz_blk - 1))) sz_blk = 1;




 ss = 512;


 fsopt = opt->fmt & (0x07 | 0x08);
 n_fat = (opt->n_fat >= 1 && opt->n_fat <= 2) ? opt->n_fat : 1;
 n_root = (opt->n_root >= 1 && opt->n_root <= 32768 && (opt->n_root % (ss / 32)) == 0) ? opt->n_root : 512;
 sz_au = (opt->au_size <= 0x1000000 && (opt->au_size & (opt->au_size - 1)) == 0) ? opt->au_size : 0;
 sz_au /= ss;


 sz_buf = len / ss;
 if (sz_buf == 0) return FR_NOT_ENOUGH_CORE;
 buf = (BYTE*)work;

 if (!buf) buf = ff_memalloc(sz_buf * ss);

 if (!buf) return FR_NOT_ENOUGH_CORE;


 b_vol = sz_vol = 0;
 if (0 && ipart != 0) {

  if (disk_read(pdrv, buf, 0, 1) != RES_OK) { if (!work) ff_memfree(buf); return FR_DISK_ERR; };
  if (ld_word(buf + 510) != 0xAA55) { if (!work) ff_memfree(buf); return FR_MKFS_ABORTED; };
# 5900 "../Middlewares/FATFS/source/ff.c"
  {
   pte = buf + (446 + (ipart - 1) * 16);
   if (ipart > 4 || pte[4] == 0) { if (!work) ff_memfree(buf); return FR_MKFS_ABORTED; };
   b_vol = ld_dword(pte + 8);
   sz_vol = ld_dword(pte + 12);
  }
 } else {
  if (disk_ioctl(pdrv, 1, &sz_vol) != RES_OK) { if (!work) ff_memfree(buf); return FR_DISK_ERR; };
  if (!(fsopt & 0x08)) {







   {
    if (sz_vol > 63) {
     b_vol = 63; sz_vol -= b_vol;
    }
   }
  }
 }
 if (sz_vol < 128) { if (!work) ff_memfree(buf); return FR_MKFS_ABORTED; };



 do {
  if (1 && (fsopt & 0x04)) {
   if ((fsopt & 0x07) == 0x04 || sz_vol >= 0x4000000 || sz_au > 128) {
    fsty = 4; break;
   }
  }



  if (sz_au > 128) sz_au = 128;
  if (fsopt & 0x02) {
   if (!(fsopt & 0x01)) {
    fsty = 3; break;
   }
  }
  if (!(fsopt & 0x01)) { if (!work) ff_memfree(buf); return FR_INVALID_PARAMETER; };
  fsty = 2;
 } while (0);

 vsn = (DWORD)sz_vol + get_fattime();


 if (fsty == 4) {
  DWORD szb_bit, szb_case, sum, nbit, clu, clen[3];
  WCHAR ch, si;
  UINT j, st;

  if (sz_vol < 0x1000) { if (!work) ff_memfree(buf); return FR_MKFS_ABORTED; };





  if (sz_au == 0) {
   sz_au = 8;
   if (sz_vol >= 0x80000) sz_au = 64;
   if (sz_vol >= 0x4000000) sz_au = 256;
  }
  b_fat = b_vol + 32;
  sz_fat = (DWORD)((sz_vol / sz_au + 2) * 4 + ss - 1) / ss;
  b_data = (b_fat + sz_fat + sz_blk - 1) & ~((LBA_t)sz_blk - 1);
  if (b_data - b_vol >= sz_vol / 2) { if (!work) ff_memfree(buf); return FR_MKFS_ABORTED; };
  n_clst = (DWORD)(sz_vol - (b_data - b_vol)) / sz_au;
  if (n_clst <16) { if (!work) ff_memfree(buf); return FR_MKFS_ABORTED; };
  if (n_clst > 0x7FFFFFFD) { if (!work) ff_memfree(buf); return FR_MKFS_ABORTED; };

  szb_bit = (n_clst + 7) / 8;
  clen[0] = (szb_bit + sz_au * ss - 1) / (sz_au * ss);


  sect = b_data + sz_au * clen[0];
  sum = 0;
  st = 0; si = 0; i = 0; j = 0; szb_case = 0;
  do {
   switch (st) {
   case 0:
    ch = (WCHAR)ff_wtoupper(si);
    if (ch != si) {
     si++; break;
    }
    for (j = 1; (WCHAR)(si + j) && (WCHAR)(si + j) == ff_wtoupper((WCHAR)(si + j)); j++) ;
    if (j >= 128) {
     ch = 0xFFFF; st = 2; break;
    }
    st = 1;

   case 1:
    ch = si++;
    if (--j == 0) st = 0;
    break;

   default:
    ch = (WCHAR)j; si += (WCHAR)j;
    st = 0;
   }
   sum = xsum32(buf[i + 0] = (BYTE)ch, sum);
   sum = xsum32(buf[i + 1] = (BYTE)(ch >> 8), sum);
   i += 2; szb_case += 2;
   if (si == 0 || i == sz_buf * ss) {
    n = (i + ss - 1) / ss;
    if (disk_write(pdrv, buf, sect, n) != RES_OK) { if (!work) ff_memfree(buf); return FR_DISK_ERR; };
    sect += n; i = 0;
   }
  } while (si);
  clen[1] = (szb_case + sz_au * ss - 1) / (sz_au * ss);
  clen[2] = 1;


  sect = b_data; nsect = (szb_bit + ss - 1) / ss;
  nbit = clen[0] + clen[1] + clen[2];
  do {
   memset(buf, 0, sz_buf * ss);
   for (i = 0; nbit != 0 && i / 8 < sz_buf * ss; buf[i / 8] |= 1 << (i % 8), i++, nbit--) ;
   n = (nsect > sz_buf) ? sz_buf : nsect;
   if (disk_write(pdrv, buf, sect, n) != RES_OK) { if (!work) ff_memfree(buf); return FR_DISK_ERR; };
   sect += n; nsect -= n;
  } while (nsect);


  sect = b_fat; nsect = sz_fat;
  j = nbit = clu = 0;
  do {
   memset(buf, 0, sz_buf * ss); i = 0;
   if (clu == 0) {
    st_dword(buf + i, 0xFFFFFFF8); i += 4; clu++;
    st_dword(buf + i, 0xFFFFFFFF); i += 4; clu++;
   }
   do {
    while (nbit != 0 && i < sz_buf * ss) {
     st_dword(buf + i, (nbit > 1) ? clu + 1 : 0xFFFFFFFF);
     i += 4; clu++; nbit--;
    }
    if (nbit == 0 && j < 3) nbit = clen[j++];
   } while (nbit != 0 && i < sz_buf * ss);
   n = (nsect > sz_buf) ? sz_buf : nsect;
   if (disk_write(pdrv, buf, sect, n) != RES_OK) { if (!work) ff_memfree(buf); return FR_DISK_ERR; };
   sect += n; nsect -= n;
  } while (nsect);


  memset(buf, 0, sz_buf * ss);
  buf[32 * 0 + 0] = 0x83;
  buf[32 * 1 + 0] = 0x81;
  st_dword(buf + 32 * 1 + 20, 2);
  st_dword(buf + 32 * 1 + 24, szb_bit);
  buf[32 * 2 + 0] = 0x82;
  st_dword(buf + 32 * 2 + 4, sum);
  st_dword(buf + 32 * 2 + 20, 2 + clen[0]);
  st_dword(buf + 32 * 2 + 24, szb_case);
  sect = b_data + sz_au * (clen[0] + clen[1]); nsect = sz_au;
  do {
   n = (nsect > sz_buf) ? sz_buf : nsect;
   if (disk_write(pdrv, buf, sect, n) != RES_OK) { if (!work) ff_memfree(buf); return FR_DISK_ERR; };
   memset(buf, 0, ss);
   sect += n; nsect -= n;
  } while (nsect);


  sect = b_vol;
  for (n = 0; n < 2; n++) {

   memset(buf, 0, ss);
   memcpy(buf + 0, "\xEB\x76\x90" "EXFAT   ", 11);
   st_qword(buf + 64, b_vol);
   st_qword(buf + 72, sz_vol);
   st_dword(buf + 80, (DWORD)(b_fat - b_vol));
   st_dword(buf + 84, sz_fat);
   st_dword(buf + 88, (DWORD)(b_data - b_vol));
   st_dword(buf + 92, n_clst);
   st_dword(buf + 96, 2 + clen[0] + clen[1]);
   st_dword(buf + 100, vsn);
   st_word(buf + 104, 0x100);
   for (buf[108] = 0, i = ss; i >>= 1; buf[108]++) ;
   for (buf[109] = 0, i = sz_au; i >>= 1; buf[109]++) ;
   buf[110] = 1;
   buf[111] = 0x80;
   st_word(buf + 120, 0xFEEB);
   st_word(buf + 510, 0xAA55);
   for (i = sum = 0; i < ss; i++) {
    if (i != 106 && i != 106 + 1 && i != 112) sum = xsum32(buf[i], sum);
   }
   if (disk_write(pdrv, buf, sect++, 1) != RES_OK) { if (!work) ff_memfree(buf); return FR_DISK_ERR; };

   memset(buf, 0, ss);
   st_word(buf + ss - 2, 0xAA55);
   for (j = 1; j < 9; j++) {
    for (i = 0; i < ss; sum = xsum32(buf[i++], sum)) ;
    if (disk_write(pdrv, buf, sect++, 1) != RES_OK) { if (!work) ff_memfree(buf); return FR_DISK_ERR; };
   }

   memset(buf, 0, ss);
   for ( ; j < 11; j++) {
    for (i = 0; i < ss; sum = xsum32(buf[i++], sum)) ;
    if (disk_write(pdrv, buf, sect++, 1) != RES_OK) { if (!work) ff_memfree(buf); return FR_DISK_ERR; };
   }

   for (i = 0; i < ss; i += 4) st_dword(buf + i, sum);
   if (disk_write(pdrv, buf, sect++, 1) != RES_OK) { if (!work) ff_memfree(buf); return FR_DISK_ERR; };
  }

 } else

 {
  do {
   pau = sz_au;

   if (fsty == 3) {
    if (pau == 0) {
     n = (DWORD)sz_vol / 0x20000;
     for (i = 0, pau = 1; cst32[i] && cst32[i] <= n; i++, pau <<= 1) ;
    }
    n_clst = (DWORD)sz_vol / pau;
    sz_fat = (n_clst * 4 + 8 + ss - 1) / ss;
    sz_rsv = 32;
    sz_dir = 0;
    if (n_clst <= 0xFFF5 || n_clst > 0x0FFFFFF5) { if (!work) ff_memfree(buf); return FR_MKFS_ABORTED; };
   } else {
    if (pau == 0) {
     n = (DWORD)sz_vol / 0x1000;
     for (i = 0, pau = 1; cst[i] && cst[i] <= n; i++, pau <<= 1) ;
    }
    n_clst = (DWORD)sz_vol / pau;
    if (n_clst > 0xFF5) {
     n = n_clst * 2 + 4;
    } else {
     fsty = 1;
     n = (n_clst * 3 + 1) / 2 + 3;
    }
    sz_fat = (n + ss - 1) / ss;
    sz_rsv = 1;
    sz_dir = (DWORD)n_root * 32 / ss;
   }
   b_fat = b_vol + sz_rsv;
   b_data = b_fat + sz_fat * n_fat + sz_dir;


   n = (DWORD)(((b_data + sz_blk - 1) & ~(sz_blk - 1)) - b_data);
   if (fsty == 3) {
    sz_rsv += n; b_fat += n;
   } else {
    if (n % n_fat) {
     n--; sz_rsv++; b_fat++;
    }
    sz_fat += n / n_fat;
   }


   if (sz_vol < b_data + pau * 16 - b_vol) { if (!work) ff_memfree(buf); return FR_MKFS_ABORTED; };
   n_clst = ((DWORD)sz_vol - sz_rsv - sz_fat * n_fat - sz_dir) / pau;
   if (fsty == 3) {
    if (n_clst <= 0xFFF5) {
     if (sz_au == 0 && (sz_au = pau / 2) != 0) continue;
     { if (!work) ff_memfree(buf); return FR_MKFS_ABORTED; };
    }
   }
   if (fsty == 2) {
    if (n_clst > 0xFFF5) {
     if (sz_au == 0 && (pau * 2) <= 64) {
      sz_au = pau * 2; continue;
     }
     if ((fsopt & 0x02)) {
      fsty = 3; continue;
     }
     if (sz_au == 0 && (sz_au = pau * 2) <= 128) continue;
     { if (!work) ff_memfree(buf); return FR_MKFS_ABORTED; };
    }
    if (n_clst <= 0xFF5) {
     if (sz_au == 0 && (sz_au = pau * 2) <= 128) continue;
     { if (!work) ff_memfree(buf); return FR_MKFS_ABORTED; };
    }
   }
   if (fsty == 1 && n_clst > 0xFF5) { if (!work) ff_memfree(buf); return FR_MKFS_ABORTED; };


   break;
  } while (1);






  memset(buf, 0, ss);
  memcpy(buf + 0, "\xEB\xFE\x90" "MSDOS5.0", 11);
  st_word(buf + 11, ss);
  buf[13] = (BYTE)pau;
  st_word(buf + 14, (WORD)sz_rsv);
  buf[16] = (BYTE)n_fat;
  st_word(buf + 17, (WORD)((fsty == 3) ? 0 : n_root));
  if (sz_vol < 0x10000) {
   st_word(buf + 19, (WORD)sz_vol);
  } else {
   st_dword(buf + 32, (DWORD)sz_vol);
  }
  buf[21] = 0xF8;
  st_word(buf + 24, 63);
  st_word(buf + 26, 255);
  st_dword(buf + 28, (DWORD)b_vol);
  if (fsty == 3) {
   st_dword(buf + 67, vsn);
   st_dword(buf + 36, sz_fat);
   st_dword(buf + 44, 2);
   st_word(buf + 48, 1);
   st_word(buf + 50, 6);
   buf[64] = 0x80;
   buf[66] = 0x29;
   memcpy(buf + 71, "NO NAME    " "FAT32   ", 19);
  } else {
   st_dword(buf + 39, vsn);
   st_word(buf + 22, (WORD)sz_fat);
   buf[36] = 0x80;
   buf[38] = 0x29;
   memcpy(buf + 43, "NO NAME    " "FAT     ", 19);
  }
  st_word(buf + 510, 0xAA55);
  if (disk_write(pdrv, buf, b_vol, 1) != RES_OK) { if (!work) ff_memfree(buf); return FR_DISK_ERR; };


  if (fsty == 3) {
   disk_write(pdrv, buf, b_vol + 6, 1);
   memset(buf, 0, ss);
   st_dword(buf + 0, 0x41615252);
   st_dword(buf + 484, 0x61417272);
   st_dword(buf + 488, n_clst - 1);
   st_dword(buf + 492, 2);
   st_word(buf + 510, 0xAA55);
   disk_write(pdrv, buf, b_vol + 7, 1);
   disk_write(pdrv, buf, b_vol + 1, 1);
  }


  memset(buf, 0, sz_buf * ss);
  sect = b_fat;
  for (i = 0; i < n_fat; i++) {
   if (fsty == 3) {
    st_dword(buf + 0, 0xFFFFFFF8);
    st_dword(buf + 4, 0xFFFFFFFF);
    st_dword(buf + 8, 0x0FFFFFFF);
   } else {
    st_dword(buf + 0, (fsty == 1) ? 0xFFFFF8 : 0xFFFFFFF8);
   }
   nsect = sz_fat;
   do {
    n = (nsect > sz_buf) ? sz_buf : nsect;
    if (disk_write(pdrv, buf, sect, (UINT)n) != RES_OK) { if (!work) ff_memfree(buf); return FR_DISK_ERR; };
    memset(buf, 0, ss);
    sect += n; nsect -= n;
   } while (nsect);
  }


  nsect = (fsty == 3) ? pau : sz_dir;
  do {
   n = (nsect > sz_buf) ? sz_buf : nsect;
   if (disk_write(pdrv, buf, sect, (UINT)n) != RES_OK) { if (!work) ff_memfree(buf); return FR_DISK_ERR; };
   sect += n; nsect -= n;
  } while (nsect);
 }




 if (1 && fsty == 4) {
  sys = 0x07;
 } else {
  if (fsty == 3) {
   sys = 0x0C;
  } else {
   if (sz_vol >= 0x10000) {
    sys = 0x06;
   } else {
    sys = (fsty == 2) ? 0x04 : 0x01;
   }
  }
 }


 if (0 && ipart != 0) {
  if (!0 || !(fsopt & 0x80)) {

   if (disk_read(pdrv, buf, 0, 1) != RES_OK) { if (!work) ff_memfree(buf); return FR_DISK_ERR; };
   buf[446 + (ipart - 1) * 16 + 4] = sys;
   if (disk_write(pdrv, buf, 0, 1) != RES_OK) { if (!work) ff_memfree(buf); return FR_DISK_ERR; };
  }
 } else {
  if (!(fsopt & 0x08)) {
   lba[0] = sz_vol; lba[1] = 0;
   fr = create_partition(pdrv, lba, sys, buf);
   if (fr != FR_OK) { if (!work) ff_memfree(buf); return fr; };
  }
 }

 if (disk_ioctl(pdrv, 0, 0) != RES_OK) { if (!work) ff_memfree(buf); return FR_DISK_ERR; };

 { if (!work) ff_memfree(buf); return FR_OK; };
}
# 6347 "../Middlewares/FATFS/source/ff.c"
TCHAR* f_gets (
 TCHAR* buff,
 int len,
 FIL* fp
)
{
 int nc = 0;
 TCHAR *p = buff;
 BYTE s[4];
 UINT rc;
 DWORD dc;
# 6453 "../Middlewares/FATFS/source/ff.c"
 len -= 1;
 while (nc < len) {
  f_read(fp, s, 1, &rc);
  if (rc != 1) break;
  dc = s[0];
  if (1 == 2 && dc == '\r') continue;
  *p++ = (TCHAR)dc; nc++;
  if (dc == '\n') break;
 }


 *p = 0;
 return nc ? buff : 0;
}





# 1 "E:\\dianzi\\MDKv5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdarg.h" 1 3
# 40 "E:\\dianzi\\MDKv5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdarg.h" 3
  typedef __builtin_va_list va_list;
# 134 "E:\\dianzi\\MDKv5\\ARM\\ARMCLANG\\Bin\\..\\include\\stdarg.h" 3
     typedef va_list __gnuc_va_list;
# 6473 "../Middlewares/FATFS/source/ff.c" 2
# 6482 "../Middlewares/FATFS/source/ff.c"
typedef struct {
 FIL *fp;
 int idx, nchr;






 BYTE buf[64];
} putbuff;




static void putc_bfd (putbuff* pb, TCHAR c)
{
 UINT n;
 int i, nc;
# 6509 "../Middlewares/FATFS/source/ff.c"
 if (1 == 2 && c == '\n') {
  putc_bfd(pb, '\r');
 }

 i = pb->idx;
 if (i < 0) return;
 nc = pb->nchr;
# 6614 "../Middlewares/FATFS/source/ff.c"
 pb->buf[i++] = (BYTE)c;


 if (i >= (int)(sizeof pb->buf) - 4) {
  f_write(pb->fp, pb->buf, (UINT)i, &n);
  i = (n == (UINT)i) ? 0 : -1;
 }
 pb->idx = i;
 pb->nchr = nc + 1;
}




static int putc_flush (putbuff* pb)
{
 UINT nw;

 if ( pb->idx >= 0
  && f_write(pb->fp, pb->buf, (UINT)pb->idx, &nw) == FR_OK
  && (UINT)pb->idx == nw) return pb->nchr;
 return -1;
}




static void putc_init (putbuff* pb, FIL* fp)
{
 memset(pb, 0, sizeof (putbuff));
 pb->fp = fp;
}



int f_putc (
 TCHAR c,
 FIL* fp
)
{
 putbuff pb;


 putc_init(&pb, fp);
 putc_bfd(&pb, c);
 return putc_flush(&pb);
}
# 6669 "../Middlewares/FATFS/source/ff.c"
int f_puts (
 const TCHAR* str,
 FIL* fp
)
{
 putbuff pb;


 putc_init(&pb, fp);
 while (*str) putc_bfd(&pb, *str++);
 return putc_flush(&pb);
}
# 6810 "../Middlewares/FATFS/source/ff.c"
int f_printf (
 FIL* fp,
 const TCHAR* fmt,
 ...
)
{
 va_list arp;
 putbuff pb;
 UINT i, j, w, f, r;
 int prec;



 DWORD v;

 TCHAR tc, pad, *tp;
 TCHAR nul = 0;
 char d, str[32];


 putc_init(&pb, fp);

 __builtin_va_start(arp, fmt);

 for (;;) {
  tc = *fmt++;
  if (tc == 0) break;
  if (tc != '%') {
   putc_bfd(&pb, tc);
   continue;
  }
  f = w = 0; pad = ' '; prec = -1;
  tc = *fmt++;
  if (tc == '0') {
   pad = '0'; tc = *fmt++;
  } else if (tc == '-') {
   f = 2; tc = *fmt++;
  }
  if (tc == '*') {
   w = __builtin_va_arg(arp, int);
   tc = *fmt++;
  } else {
   while (((tc) >= '0' && (tc) <= '9')) {
    w = w * 10 + tc - '0';
    tc = *fmt++;
   }
  }
  if (tc == '.') {
   tc = *fmt++;
   if (tc == '*') {
    prec = __builtin_va_arg(arp, int);
    tc = *fmt++;
   } else {
    prec = 0;
    while (((tc) >= '0' && (tc) <= '9')) {
     prec = prec * 10 + tc - '0';
     tc = *fmt++;
    }
   }
  }
  if (tc == 'l') {
   f |= 4; tc = *fmt++;





  }
  if (tc == 0) break;
  switch (tc) {
  case 'b':
   r = 2; break;
  case 'o':
   r = 8; break;
  case 'd':
  case 'u':
   r = 10; break;
  case 'x':
  case 'X':
   r = 16; break;
  case 'c':
   putc_bfd(&pb, (TCHAR)__builtin_va_arg(arp, int));
   continue;
  case 's':
   tp = __builtin_va_arg(arp, TCHAR*);
   if (!tp) tp = &nul;
   for (j = 0; tp[j]; j++) ;
   if (prec >= 0 && j > (UINT)prec) j = prec;
   for ( ; !(f & 2) && j < w; j++) putc_bfd(&pb, pad);
   while (*tp && prec--) putc_bfd(&pb, *tp++);
   while (j++ < w) putc_bfd(&pb, ' ');
   continue;
# 6912 "../Middlewares/FATFS/source/ff.c"
  default:
   putc_bfd(&pb, tc); continue;
  }
# 6931 "../Middlewares/FATFS/source/ff.c"
  if (f & 4) {
   v = (DWORD)__builtin_va_arg(arp, long);
  } else {
   v = (tc == 'd') ? (DWORD)(long)__builtin_va_arg(arp, int) : (DWORD)__builtin_va_arg(arp, unsigned int);
  }
  if (tc == 'd' && (v & 0x80000000)) {
   v = 0 - v; f |= 1;
  }

  i = 0;
  do {
   d = (char)(v % r); v /= r;
   if (d > 9) d += (tc == 'x') ? 0x27 : 0x07;
   str[i++] = d + '0';
  } while (v && i < 32);
  if (f & 1) str[i++] = '-';

  for (j = i; !(f & 2) && j < w; j++) putc_bfd(&pb, pad);
  do putc_bfd(&pb, (TCHAR)str[--i]); while (i);
  while (j++ < w) putc_bfd(&pb, ' ');
 }

 __builtin_va_end(arp);

 return putc_flush(&pb);
}
