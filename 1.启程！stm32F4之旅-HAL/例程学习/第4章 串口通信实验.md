# 第四章 串口通信实验

## 1. 硬件设计

本实验需要使用的硬件资源有：

1. 指示灯DS0

2. 串口1

串口 1 之前还没有介绍过，本实验用到的串口 1 与 USB 串口并没有在 PCB 上连接在一起，需要通过跳线帽来连接一下。这里我们把 P6 的 RXD 和 TXD 用跳线帽与 PA9 和 PA10 连接起来。

![屏幕截图 2024 09 09 111837](https://img.picgo.net/2024/09/09/-2024-09-09-11183711325e79d133efb1.png)

连接上这里之后，我们在硬件上就设置完成了，可以开始软件设计了。

## 2. 软件设计

本章的代码设计，比前两章简单很多，因为我们的串口初始化代码和接收代码就是用我们之前介绍的 SYSTEM 文件夹下的串口部分的内容。

打开串口实验工程，然后在SYSTEM组下双击usart.c，我们就可以看到该文件里面的代码，先介绍 uart_init 函数，该函数代码如下：

```c
// 初始化 IO 串口 1
// bound:波特率
void uart_init(u32 bound)
{
    // UART 初始化设置
    UART1_Handler.Instance = USART1; //USART1
    UART1_Handler.Init.BaudRate = bound; //波特率
    UART1_Handler.Init.WordLength = UART_WORDLENGTH_8B; //字长为 8 位数据格式
    UART1_Handler.Init.StopBits = UART_STOPBITS_1; //一个停止位
    UART1_Handler.Init.Parity = UART_PARITY_NONE; //无奇偶校验位
    UART1_Handler.Init.HwFlowCtl = UART_HWCONTROL_NONE; //无硬件流控
    UART1_Handler.Init.Mode = UART_MODE_TX_RX; //收发模式
    HAL_UART_Init(&UART1_Handler); //HAL_UART_Init()会使能 UART1
    HAL_UART_Receive_IT(&UART1_Handler, (u8 *)aRxBuffer, RXBUFFERSIZE);
    // 该函数会开启接收中断：标志位 UART_IT_RXNE，并且设置接收缓冲以
    // 及接收缓冲接收最大数据量
}
```

同时这里大家需要注意，最后一行代码调用函数 HAL_UART_Receive_IT，作用是开启接收中断，同时设置接收的缓存区以及接收的数据量，对于这个缓冲我们在后面会给大家讲解它的作用。

串口 MSP 函数 HAL_UART_MspInit 函数我们自定义了其内容，代码如下：

```c
void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{        
    // GPIO 端口设置
    GPIO_InitTypeDef GPIO_Initure;
    if(huart->Instance == USART1) //如果是串口 1，进行串口 1 MSP 初始化
    {
        __HAL_RCC_GPIOA_CLK_ENABLE(); //使能 GPIOA 时钟
        __HAL_RCC_USART1_CLK_ENABLE(); //使能 USART1 时钟
        GPIO_Initure.Pin=GPIO_PIN_9; //PA9
        GPIO_Initure.Mode=GPIO_MODE_AF_PP; //复用推挽输出
        GPIO_Initure.Pull=GPIO_PULLUP; //上拉
        GPIO_Initure.Speed=GPIO_SPEED_FAST; //高速
        GPIO_Initure.Alternate=GPIO_AF7_USART1; //复用为 USART1
        HAL_GPIO_Init(GPIOA,&GPIO_Initure); //初始化 PA9
        GPIO_Initure.Pin=GPIO_PIN_10; //PA10
        HAL_GPIO_Init(GPIOA,&GPIO_Initure); //初始化 PA10
#if EN_USART1_RX
        HAL_NVIC_EnableIRQ(USART1_IRQn); //使能 USART1 中断通道
        HAL_NVIC_SetPriority(USART1_IRQn,3,3); //抢占优先级 3，子优先级 3
#endif
    }
}
```

这里大家需要注意，在该段代码中，通过判断宏定义标识符 EN_USART1_RX 的值来确定是否开启串口中断通道和设置串口 1 中断优先级。标识符 EN_USART1_RX 在头文件 usart.h 中有定义，默认情况下我们设置为1。

```c
#define EN_USART1_RX 1 // 使能（1）/ 禁止（0）串口 1 接收
```

通过上面两个函数，我们就配置了串口相关设置。接下来就是编写中断服务函数USART1_IRQHandler。而 HAL 库中，对中断服务函数的编写有非常严格的讲究。

首先 HAL 库定义了一个串口中断处理通用函数 HAL_UART_IRQHandler，该函数声明如下：

```c
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart);
```

该函数只有一个入口参数就是 UART_HandleTypeDef 结构体指针类型的串口句柄 huart，使用我们在调用 HAL_UART_Init 函数时设置的同一个变量即可。该函数一般在中断服务函数中调用，作为串口中断处理的通用入口。

```c
void USART1_IRQHandler(void)
{        
    HAL_UART_IRQHandler(&UART1_Handler); //调用 HAL 库中断处理公用函数
    …//中断处理完成后的结束工作
}
```

也就是说，真正的串口中断处理逻辑我们会最终在函数HAL_UART_IRQHandler 内部执行。而该函数是 HAL 库已经定义好，而且用户一般不能随意修改。这个时候大家会问，那么我们的中断控制逻 辑编写在哪里呢? 为了把这个问题讲解清楚 ，我们要来看看函数HAL_UART_IRQHandler 内部具体实现过程。因为本章实验，我们主要实现的是串口中断接收，也就是每次接收到一个字符后进入中断服务函数来处理。所以我们就以中断接收为例给大家讲解。

函数 HAL_UART_IRQHandler 关于串口接收相关源码如下：

```c
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{    
    uint32_t tmp1 = 0, tmp2 = 0;
    …//此处省略部分代码
    tmp1 = __HAL_UART_GET_FLAG(huart, UART_FLAG_RXNE);
    tmp2 = __HAL_UART_GET_IT_SOURCE(huart, UART_IT_RXNE);
    if((tmp1 != RESET) && (tmp2 != RESET))
    {
        UART_Receive_IT(huart);
    } …
//此处省略部分代码
}
```

从代码逻辑可以看出，在函数 HAL_UART_IRQHandler 内部通过判断中断类型是否为接收完成中断，确定是否调用 HAL 另外一个函数 UART_Receive_IT()。函数 UART_Receive_IT()的作用是把每次中断接收到的字符保存在串口句柄的缓存指针 pRxBuffPtr 中，同时每次接收一个字符，其计数器 RxXferCount 减 1，直到接收完成 RxXferSize 个字符之后 RxXferCount 设置为0，同时调用接收完成回调函数 HAL_UART_RxCpltCallback 进行处理。为了篇幅考虑，这里我们仅列出 UART_Receive_IT()函数调用回调函数 HAL_UART_RxCpltCallback 的处理逻辑，代码如下：

```c
static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
{    
    ...//此处省略部分代码
    if(--huart->RxXferCount == 0)    
    {
        HAL_UART_RxCpltCallback(huart);
    } 
...//此处省略部分代码
}
```

最后我们列出串口接收中断的一般流程:

<img src="https://img.picgo.net/2024/09/09/-2024-09-09-112731138facf81afd03b3.png" title="" alt="屏幕截图 2024 09 09 112731" width="499">

这里，我们再把串口接收中断的一般流程进行概括：当接收到一个字符之后， 在函数UART_Receive_IT中会把数据保存在串口句柄的成员变量pRxBuffPtr缓存中，同时RxXferCount计数器减 1。如果我们设置 RxXferSize=10,那么当接收到 10 个字符之后， RxXferCount 会由 10减到 0（ RxXferCount 初始值等于 RxXferSize），这个时候再调用接收完成回调函数HAL_UART_RxCpltCallback 进行处理。接下来我们看看我们的配置。

首先，我们回到用户函数 uart_init 定义可以看到，在 uart_init 函数中调用完 HAL_UART_Init后我们还调用了 HAL_UART_Receive_IT 开启接收中断，并且初始化串口句柄的缓存相关参数。代码如下：

```c
HAL_UART_Receive_IT(&UART1_Handler, (u8 *)aRxBuffer, RXBUFFERSIZE);
```

而 aRxBuffer 是我们定义的一个全局数组变量， RXBUFFERSIZE 是我们定义的一个标识符：

```c
#define RXBUFFERSIZE 1
u8 aRxBuffer[RXBUFFERSIZE];
```

所以，调用 HAL_UART_Receive_IT 函数后，除了开启接收中断外还确定了每次接收RXBUFFERSIZE 个字符后标示接收结束从而进入回调函数 HAL_UART_RxCpltCallback 进行相应处理。最后我们看看 HAL_UART_RxCpltCallback 函数定义：

```c
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{    
    if(huart->Instance == USART1) // 如果是串口 1
        if((USART_RX_STA&0x8000) == 0) // 接收未完成
        {
            if(USART_RX_STA&0x4000)//接收到了 0x0d
            {   
                if(aRxBuffer[0]!=0x0a)USART_RX_STA=0; // 接收错误,重新开始
                else USART_RX_STA|=0x8000; // 接收完成了
            }
            else // 还没收到 0X0D
            {
                if(aRxBuffer[0]==0x0d)USART_RX_STA|=0x4000;
                else
                {
                    USART_RX_BUF[USART_RX_STA&0X3FFF]=aRxBuffer[0] ;
                    USART_RX_STA++;
                    if(USART_RX_STA>(USART_REC_LEN-1))USART_RX_STA=0;
                    // 接收数据错误,重新开始接收
                }
            }
        }
    }
}
```

因为我们设置了串口句柄成员变量 RxXferSize 为 1，也就是每当串口 1 发生了接收完成中断后（接收到一个字符），就会跳到该函数执行。 当串口接受到一个字符后，它会保存在缓存aRxBuffer 中，由于我们设置了缓存大小为 1，而且 RxXferSize=1，所以每次接受一个字符，回直接保存到 RxXferSize[0]中，我们直接通过读取 RxXferSize[0]的值就是本次接收到的字符。 这里我们设计了一个小小的接收协议：通过这个函数，配合一个数组 USART_RX_BUF[]，一个接收状态寄存器 USART_RX_STA（此寄存器其实就是一个全局变量，由作者自行添加。由于它起到类似寄存器的功能 ， 这里暂且称之为寄存器 ）实现对串口数据的接收管理。USART_RX_BUF 的大小由 USART_REC_LEN 定义，也就是一次接收的数据最大不能超过USART_REC_LEN 个字节。

![屏幕截图 2024 09 09 113522](https://img.picgo.net/2024/09/09/-2024-09-09-11352282ac938d1453cfde.png)

设计思路如下：

当接收到从电脑发过来的数据，把接收到的数据保存在 USART_RX_BUF 中，同时在接收状态寄存器（USART_RX_STA）中计数接收到的有效数据个数，当收到回车（回车的表示由 2 个字节组成： 0X0D 和 0X0A）的第一个字节 0X0D 时，计数器将不再增加，等待 0X0A 的到来，而如果 0X0A 没有来到，则认为这次接收失败，重新开始下一次接收。如果顺利接收到 0X0A，则标记 USART_RX_STA 的第 15 位，这样完成一次接收，并等待该位被其他程序清除，从而开始下一次的接收，而如果迟迟没有收到0X0D，那么在接收数据超过USART_REC_LEN的时候，则会丢弃前面的数据，重新接收。

在函数 USART1_IRQHandler 的结尾还有几行行代码，其中部分代码是超时退出逻辑，关键逻辑代码如下：

```c
while (HAL_UART_GetState(&UART1_Handler) != HAL_UART_STATE_READY);
while(HAL_UART_Receive_IT(&UART1_Handler, (u8 *)aRxBuffer, 1) != HAL_OK);
```

这两行代码作用非常简单。第一行代码是判断串口是否就绪，如果没有就绪就等待就绪。第二行代码是继续调用 HAL_UART_Receive_IT 函数来开启中断和重新设置 RxXferSize 和RxXferCount 的初始值为 1，也就是开启新的接收中断。

学到这里大家会发现， HAL 库定义的串口中断逻辑确实非常复杂，并且因为处理过程繁琐所以效率不高。这里我们需要说明的是，在中断服务函数中，大家也可以不用调用HAL_UART_IRQHandler 函数，而是直接编写自己的中断服务函数。串口实验我们之所以遵循 HAL 库写法， 是为了让大家对 HAL 库有一个更清晰的理解。

如果我们不用中断处理回调函数，那么就不用初始化串口句柄的中断接收缓存，所以我们HAL_UART_Receive_IT 函数就不用出现在初始化函数 uart_init 中，而是直接在要开启中断的地方通过调用__HAL_UART_ENABLE_IT 单独开启中断即可。如果不用中断回调函数处理，中断服务函数内容为：

```c
// 串口 1 中断服务程序
void USART1_IRQHandler(void)
{
    u8 Res;
#if SYSTEM_SUPPORT_OS //使用 OS
    OSIntEnter();
#endif
if((__HAL_UART_GET_FLAG(&UART1_Handler,UART_FLAG_RXNE)!=RESET))
//接收中断(接收到的数据必须是 0x0d 0x0a 结尾)
{
    HAL_UART_Receive(&UART1_Handler,&Res,1,1000);
    if((USART_RX_STA&0x8000)==0)//接收未完成
    {
        if(USART_RX_STA&0x4000)//接收到了 0x0d
        {
            if(Res!=0x0a)USART_RX_STA=0;//接收错误,重新开始
            else USART_RX_STA|=0x8000; //接收完成了
        }
        else //还没收到 0X0D
        {
            if(Res==0x0d)USART_RX_STA|=0x4000;
            else
            {
                USART_RX_BUF[USART_RX_STA&0X3FFF]=Res ;
                USART_RX_STA++;
                if(USART_RX_STA>(USART_REC_LEN-1))USART_RX_STA=0;
                //接收数据错误,重新开始接收
            }
        }
    }
}
    HAL_UART_IRQHandler(&UART1_Handler);
#if SYSTEM_SUPPORT_OS //使用 OS
    OSIntExit();
#endif
}
```

这段代码逻辑跟上面的中断回调函数类似，只不过这里还需要通过 HAL 库串口接收函数HAL_UART_Receive 来获取接收到的字符进行相应的处理，这里我们就不做过多讲解。 在我们后面很多实验，为了效率和处理逻辑方便，我们会选择将接收控制逻辑直接编写在中断服务函数内部。

HAL 库一共提供了 5 个中断处理回调函数：

```c
void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart);//发送完成回调函数
void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart);//发送完成过半
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart);//接收完成回调函数
void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart);//接收完成过半
void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart);//错误处理回调函数
```

下面就只看主函数了：

```c
int main(void)
{
    u8 len; // 接收到的数据长度    
    u16 times = 0; // 接收到的数据次数

    HAL_Init();                  // 初始化HAL库    
    Stm32_Clock_Init(336,8,2,7); // 设置时钟,168Mhz
    delay_init(168);             // 初始化延时函数
    uart_init(115200);           // 初始化USART
    LED_Init();                  // 初始化LED    
    KEY_Init();                  // 初始化按键

    while(1)
    {
       if(USART_RX_STA&0x8000) // 判断是否有数据接收
        {                       
            len = USART_RX_STA&0x3fff;//得到此次接收到的数据长度
            printf("\r\n您发送的消息为:\r\n");
            HAL_UART_Transmit(&UART1_Handler,(uint8_t*)USART_RX_BUF,len,1000);    // 发送接收到的数据
            while(__HAL_UART_GET_FLAG(&UART1_Handler,UART_FLAG_TC)!=SET);        // 等待发送结束
            printf("\r\n\r\n"); // 插入换行
            USART_RX_STA = 0; // 清空接收状态
        }
        else
        {
            times++;
            if(times % 5000 == 0)
            {
                printf("\r\nALIENTEK 探索者STM32F407开发板 串口实验\r\n");
                printf("正点原子@ALIENTEK\r\n\r\n\r\n");
            }
            if(times % 200 ==0 )
                printf("请输入数据,以回车键结束\r\n");  
            if(times %30 == 0)
                LED0=!LED0;//闪烁LED,提示系统正在运行.
            delay_ms(10);   
        } 
    }
}
```

这段代码比较简单， 调用 uart_init 函数，设置波特率为 115200。接下来我们重点看下以下两句：

```c
USART1->DR=USART_RX_BUF[t];
while((USART1->SR&0X40)==0); // 等待发送结束
```

第一句，其实就是发送一个字节到串口。第二句呢，就是我们在我们发送一个数据到串口之后，要检测这个数据是否已经被发送完成了。
