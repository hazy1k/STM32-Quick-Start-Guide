# 第五章 外部中断实验

## 1. 硬件设计

本实验用到的硬件资源和按键输入实验一模一样，不多介绍了

但是这里我们使用的是中断来检测按键，还是KEY_UP 控制 DS0， DS1 互斥点亮； KEY2 控制 DS0， 按一次亮，再按一次灭； KEY1 控制 DS1，效果同 KEY2； KEY0 则同时控制 DS0 和 DS1，按一次，他们的状态就翻转一次。

## 2. 软件设计

- GPIO初始化

```c
// 外部中断初始化
void EXTI_Init(void)
{
    GPIO_InitTypeDef GPIO_Initure;
    
    __HAL_RCC_GPIOA_CLK_ENABLE(); // 开启GPIOA时钟
    __HAL_RCC_GPIOE_CLK_ENABLE(); // 开启GPIOE时钟
    
    GPIO_Initure.Pin = GPIO_PIN_0;          // PA0
    GPIO_Initure.Mode = GPIO_MODE_IT_RISING;// 上升沿触发
    GPIO_Initure.Pull = GPIO_PULLDOWN;
    HAL_GPIO_Init(GPIOA, &GPIO_Initure);
    
    GPIO_Initure.Pin = GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4; // PE2,3,4
    GPIO_Initure.Mode = GPIO_MODE_IT_FALLING;            // 下降沿触发
    GPIO_Initure.Pull = GPIO_PULLUP;
    HAL_GPIO_Init(GPIOE, &GPIO_Initure);
```

- NVIC配置

```c
    // 中断线0-PA0
    HAL_NVIC_SetPriority(EXTI0_IRQn, 2, 0); // 抢占优先级为2，子优先级为0
    HAL_NVIC_EnableIRQ(EXTI0_IRQn);         // 使能中断线0
    
    // 中断线2-PE2
    HAL_NVIC_SetPriority(EXTI2_IRQn, 2, 1); // 抢占优先级为2，子优先级为1
    HAL_NVIC_EnableIRQ(EXTI2_IRQn);         // 使能中断线2
    
    // 中断线3-PE3
    HAL_NVIC_SetPriority(EXTI3_IRQn, 2, 2); // 抢占优先级为2，子优先级为2
    HAL_NVIC_EnableIRQ(EXTI3_IRQn);         // 使能中断线2
    
    // 中断线4-PE4
    HAL_NVIC_SetPriority(EXTI4_IRQn, 2, 3); // 抢占优先级为2，子优先级为3
    HAL_NVIC_EnableIRQ(EXTI4_IRQn);         // 使能中断线4
}
```

- 中断服务函数

```c
// 中断服务函数
void EXTI0_IRQHandler(void)
{
    HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_0); // 调用中断处理公用函数
}

void EXTI2_IRQHandler(void)
{
    HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_2); // 调用中断处理公用函数
}

void EXTI3_IRQHandler(void)
{
    HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_3); // 调用中断处理公用函数
}

void EXTI4_IRQHandler(void)
{
    HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_4); // 调用中断处理公用函数
}
```

- 中断服务函数内容

```c
// 中断服务程序中需要做的事情
// 在HAL库中所有的外部中断服务函数都会调用此函数
// GPIO_Pin:中断引脚号
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
    delay_ms(100); // 消抖
    switch(GPIO_Pin)
    {
        case GPIO_PIN_0:
            if(WK_UP == 1) 
            {
				LED1 = !LED1; // 控制LED0,LED1互斥点亮
				LED0 = !LED1;
            }
            break;
        case GPIO_PIN_2:
            if(KEY2 == 0) // LED1翻转
            {
                LED1 = !LED1;    
            }
            break;
        case GPIO_PIN_3:
            if(KEY1 == 0) // 同时控制LED0,LED1翻转 
            {
                LED0 = !LED0;
				LED1 = !LED1;
            }
            break;
        case GPIO_PIN_4:
            if(KEY0 == 0)  
            {
				LED0 = !LED0; // 控制LED0翻转
            }
            break;
    }
}
```

- 主函数

```c

```

## 3. 重点部分分析

exti.c 文件总共包含 6 个函数。外部中断初始化函数 void EXTIX_Init 用来配置 IO 口外部中断相关步骤并使能中断，另一个函数 HAL_GPIO_EXTI_Callback 是外部中断共用回调函数，用来处理所有外部中断真正的控制逻辑。其他 4 个都是中断服务函数。

void EXTI0_IRQHandler(void)是外部中断 0 的服务函数，负责 KEY_UP 按键的中断检测；

void EXTI2_IRQHandler(void)是外部中断 2 的服务函数，负责 KEY2 按键的中断检测；

void EXTI3_IRQHandler(void)是外部中断 3 的服务函数，负责 KEY1 按键的中断检测；

void EXTI4_IRQHandler(void)是外部中断 4 的服务函数，负责 KEY0 按键的中断检测；

下面我们分别介绍这几个函数。

首先是外部中断初始化函数 void EXTIX_Init(void)， 该函数内部主要做了两件事情。首先是调用 IO 口初始化函数 HAL_GPIO_Init 来初始化 IO 口，其次是设置中断优先级并使能中断线。

接下来我们看看外部中断服务函数，一共 4 个。所有的中断服务函数内部都只调用了同样一个函数 HAL_GPIO_EXTI_IRQHandler，该函数是外部中断共用入口函数，函数内部会进行中断标志位清零， 并且调用中断处理共用回调函数 HAL_GPIO_EXTI_Callback。

最后是外部中断回调函数 HAL_GPIO_EXTI_Callback，该函数用来编写真正的外部中断控制逻辑。该函数有一个入口参数就是 IO 口序号。所以我们在该函数内部，一般通过判断 IO 口序号值来确定中断是来自哪个 IO 口，也就是哪个中断线，然后编写相应的控制逻辑。所以在该函数内部，我们通过 switch 语句判断 IO 口来源，例如是来自 GPIO_PIN_0，那么一定是来自PA0，因为中断线一次只能连接一个 IO 口，而四个 IO 口中序号为 0 的 IO 口只有 PA0，所以中断线 0 一定是连接 PA0，也就是外部中断由 PA0 触发。

exti.h 头文件里面主要是一个函数申明，比较简单，这里不做过多讲解。






