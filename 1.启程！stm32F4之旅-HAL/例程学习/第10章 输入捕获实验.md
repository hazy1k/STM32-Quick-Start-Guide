# 第十章 输入捕获实验

## 1. 硬件设计

本实验用到的硬件资源有：

- 指示灯DS0

- KEY_UP按键

- 串口

- 定时器TIM3

- 定时器TIM5

前面 4 个，在之前的章节均有介绍。 本节，我们将捕获 TIM5_CH1（ PA0）上的高电平脉宽， 通过 KEY_UP 按键输入高电平，并从串口打印高电平脉宽。同时我们保留上节的 PWM 输出，大家也可以通过用杜邦线连接 PF9 和 PA0，来测量 PWM 输出的高电平脉宽。

## 2. 软件设计

### 2.1 定时器5通道1输入捕获配置

```c
// 定时器5通道1输入捕获配置
// arr：自动重装值(TIM2,TIM5是32位的!!)
// psc：时钟预分频数
void TIM5_CH1_Cap_Init(u32 arr, u16 psc) // 函数参数：自动重装值，时钟预分频数
{  
    TIM_IC_InitTypeDef TIM5_CH1Config;  

    TIM5_Handler.Instance = TIM5;                          // 通用定时器5
    TIM5_Handler.Init.Prescaler = psc;                     // 分频系数
    TIM5_Handler.Init.CounterMode = TIM_COUNTERMODE_UP;    // 向上计数器
    TIM5_Handler.Init.Period = arr;                        // 自动装载值
    TIM5_Handler.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;// 时钟分频银子
    HAL_TIM_IC_Init(&TIM5_Handler); // 初始化输入捕获时基参数

    TIM5_CH1Config.ICPolarity = TIM_ICPOLARITY_RISING;    // 上升沿捕获
    TIM5_CH1Config.ICSelection = TIM_ICSELECTION_DIRECTTI;// 映射到TI1上
    TIM5_CH1Config.ICPrescaler = TIM_ICPSC_DIV1;          // 配置输入分频，不分频
    TIM5_CH1Config.ICFilter = 0;                          // 配置输入滤波器，不滤波
    HAL_TIM_IC_ConfigChannel(&TIM5_Handler,&TIM5_CH1Config,TIM_CHANNEL_1); // 配置TIM5通道1

    HAL_TIM_IC_Start_IT(&TIM5_Handler, TIM_CHANNEL_1);   // 开启TIM5的捕获通道1，并且开启捕获中断
    __HAL_TIM_ENABLE_IT(&TIM5_Handler, TIM_IT_UPDATE);   // 使能更新中断
}
```

### 2.2 TIM5 GPIO配置

```c
// 定时器5底层驱动，时钟使能，引脚配置
// 此函数会被HAL_TIM_IC_Init()调用
// htim:定时器5句柄
void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
{
    GPIO_InitTypeDef GPIO_Initure;
    __HAL_RCC_TIM5_CLK_ENABLE();            // 使能TIM5时钟
    __HAL_RCC_GPIOA_CLK_ENABLE();            // 开启GPIOA时钟

    GPIO_Initure.Pin = GPIO_PIN_0;          // PA0
    GPIO_Initure.Mode = GPIO_MODE_AF_PP;    // 复用推挽输出
    GPIO_Initure.Pull = GPIO_PULLDOWN;      // 下拉
    GPIO_Initure.Speed = GPIO_SPEED_HIGH;   // 高速
    GPIO_Initure.Alternate = GPIO_AF2_TIM5; // PA0复用为TIM5通道1
    HAL_GPIO_Init(GPIOA,&GPIO_Initure);     // 初始化GPIO

    HAL_NVIC_SetPriority(TIM5_IRQn,2,0);    // 设置中断优先级，抢占优先级2，子优先级0
    HAL_NVIC_EnableIRQ(TIM5_IRQn);          // 开启ITM5中断通道  
}
```

### 2.3 更新中断回调函数

```c
// 定时器更新中断（计数溢出）中断处理回调函数，该函数在HAL_TIM_IRQHandler中会被调用
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) // 更新中断（溢出）发生时执行
{

    if((TIM5CH1_CAPTURE_STA&0X80)==0) // 还未成功捕获
    {
            if(TIM5CH1_CAPTURE_STA&0X40) // 已经捕获到高电平了
            {
                if((TIM5CH1_CAPTURE_STA&0X3F)==0X3F) // 高电平太长了
                {
                    TIM5CH1_CAPTURE_STA|=0X80;      // 标记成功捕获了一次
                    TIM5CH1_CAPTURE_VAL=0XFFFFFFFF; // 捕获值置为最大值
                }
                else TIM5CH1_CAPTURE_STA++; // 捕获到一次低电平
            }     
    }        
}
```

这段代码其实有点难理解，下面我们分步骤解释一下：

#### 函数概述

```c
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
```

- 这是一个由HAL库定义的回调函数，当定时器的计数周期到达设定值（溢出）时自动调用。
- `TIM_HandleTypeDef *htim`是指向定时器句柄的指针，用于识别哪个定时器产生了中断。

#### 变量解释

- `TIM5CH1_CAPTURE_STA`: 这是一个状态变量，通常用来保存捕获的状态信息。
- `TIM5CH1_CAPTURE_VAL`: 存储捕获的值。

#### 代码逻辑

1. **检查捕获状态**：

```c
if((TIM5CH1_CAPTURE_STA & 0x80) == 0) // 还未成功捕获
```

- 检查状态标志位的第8位（0x80），如果为0，表示还没有成功捕获高电平。
2. **判断是否已经捕获到高电平**：

```c
if(TIM5CH1_CAPTURE_STA & 0x40) // 已经捕获到高电平了
```

- 检查状态标志位的第7位（0x40），如果为1，表示之前已经捕获到了高电平。
3. **捕获高电平时间过长**：

```c
if((TIM5CH1_CAPTURE_STA & 0x3F) == 0x3F) // 高电平太长了
```

- 检查状态变量的低6位（0x3F），如果等于63，表示高电平持续时间过长。
- 此时，将第8位标记为1，表示成功捕获了一次，并将捕获值设置为最大值（0xFFFFFFFF），可能是为了表示超时。
4. **捕获到一次低电平**：

```c
else TIM5CH1_CAPTURE_STA++;
```

- 如果没有达到超时，表示捕获到了一次低电平，状态计数器加1。

### 2.4 输入捕获中断捕获处理回调函数

```c
void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim) // 捕获中断发生时执行
{
    if((TIM5CH1_CAPTURE_STA&0X80)==0) // 还未成功捕获
    {
        if(TIM5CH1_CAPTURE_STA&0X40) // 捕获到一个下降沿         
        {                  
                TIM5CH1_CAPTURE_STA|=0X80;        // 标记成功捕获到一次高电平脉宽
                TIM5CH1_CAPTURE_VAL = HAL_TIM_ReadCapturedValue(&TIM5_Handler,TIM_CHANNEL_1); // 获取当前的捕获值.
                TIM_RESET_CAPTUREPOLARITY(&TIM5_Handler,TIM_CHANNEL_1); // 一定要先清除原来的设置！！
                TIM_SET_CAPTUREPOLARITY(&TIM5_Handler,TIM_CHANNEL_1, TIM_ICPOLARITY_RISING); // 配置TIM5通道1上升沿捕获
        }
        else // 还未开始,第一次捕获上升沿
        {
                TIM5CH1_CAPTURE_STA = 0;           // 清空
                TIM5CH1_CAPTURE_VAL = 0;
                TIM5CH1_CAPTURE_STA |= 0X40;       // 标记捕获到了上升沿
                __HAL_TIM_DISABLE(&TIM5_Handler);  // 关闭定时器5
                __HAL_TIM_SET_COUNTER(&TIM5_Handler,0); // 清空计数器
                TIM_RESET_CAPTUREPOLARITY(&TIM5_Handler, TIM_CHANNEL_1);  // 一定要先清除原来的设置！！
                TIM_SET_CAPTUREPOLARITY(&TIM5_Handler, TIM_CHANNEL_1, TIM_ICPOLARITY_FALLING); // 定时器5通道1设置为下降沿捕获
                __HAL_TIM_ENABLE(&TIM5_Handler); // 使能定时器5
        }            
    }        
}
```

同样，这个函数也值得我们分析一下：

#### 函数定义

```c
void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim) // 捕获中断发生时执行
```

- 这是一个回调函数，当定时器捕获中断发生时被调用，参数 `htim` 是指向定时器句柄的指针，用于识别哪个定时器触发了中断。

#### 捕获状态检查

```c
if((TIM5CH1_CAPTURE_STA & 0X80) == 0) // 还未成功捕获
```

- 检查 `TIM5CH1_CAPTURE_STA` 的第 7 位（0x80）是否为 0，表示还没有成功捕获到高电平脉宽。

#### 捕获到下降沿的处理

```c
if(TIM5CH1_CAPTURE_STA & 0X40) // 捕获到一个下降沿         
{
    TIM5CH1_CAPTURE_STA |= 0X80; // 标记成功捕获到一次高电平脉宽
    TIM5CH1_CAPTURE_VAL = HAL_TIM_ReadCapturedValue(&TIM5_Handler, TIM_CHANNEL_1); // 获取当前的捕获值.
    TIM_RESET_CAPTUREPOLARITY(&TIM5_Handler, TIM_CHANNEL_1); // 一定要先清除原来的设置！！
    TIM_SET_CAPTUREPOLARITY(&TIM5_Handler, TIM_CHANNEL_1, TIM_ICPOLARITY_RISING); // 配置TIM5通道1上升沿捕获
}
```

- 如果已经捕获到下降沿（`TIM5CH1_CAPTURE_STA` 的第 6 位为 1），则：
  - 将状态标志 `0x80` 设为 1，标记为成功捕获高电平脉宽。
  - 使用 `HAL_TIM_ReadCapturedValue` 获取当前捕获的计数值，并存储在 `TIM5CH1_CAPTURE_VAL` 中。
  - 清除之前的捕获极性设置。
  - 将捕获极性设置为上升沿，准备下次捕获。

#### 第一次捕获上升沿的处理

```c
else // 还未开始,第一次捕获上升沿
{
    TIM5CH1_CAPTURE_STA = 0;           // 清空
    TIM5CH1_CAPTURE_VAL = 0;
    TIM5CH1_CAPTURE_STA |= 0X40;       // 标记捕获到了上升沿
    __HAL_TIM_DISABLE(&TIM5_Handler);  // 关闭定时器5
    __HAL_TIM_SET_COUNTER(&TIM5_Handler, 0); // 清空计数器
    TIM_RESET_CAPTUREPOLARITY(&TIM5_Handler, TIM_CHANNEL_1);  // 一定要先清除原来的设置！！
    TIM_SET_CAPTUREPOLARITY(&TIM5_Handler, TIM_CHANNEL_1, TIM_ICPOLARITY_FALLING); // 定时器5通道1设置为下降沿捕获
    __HAL_TIM_ENABLE(&TIM5_Handler); // 使能定时器5
}
```

- 如果还没有捕获到任何边沿：
  - 清空捕获状态和捕获值。
  - 标记为已捕获到上升沿（设置 `0x40`）。
  - 关闭 TIM5 定时器，重置计数器为 0。
  - 清除之前的捕获极性设置。
  - 将捕获极性设置为下降沿，以便在下次捕获时能够检测到下降沿。
  - 重新使能 TIM5 定时器。

### 2.5 主函数

```c
extern u8  TIM5CH1_CAPTURE_STA; // 输入捕获状态                            
extern u32 TIM5CH1_CAPTURE_VAL;    // 输入捕获值 

int main(void)
{
    long long temp=0; 
    HAL_Init();                           //初始化HAL库    
    Stm32_Clock_Init(336,8,2,7);          //设置时钟,168Mhz
    delay_init(168);                       //初始化延时函数
    uart_init(115200);                     //初始化USART
    LED_Init();                            //初始化LED    
    TIM14_PWM_Init(500-1,84-1);            //84M/84=1M的计数频率，自动重装载为500，那么PWM频率为1M/500=2kHZ
    TIM5_CH1_Cap_Init(0XFFFFFFFF,84-1); //以1MHZ的频率计数

    while(1)
    {
        delay_ms(10);
        TIM_SetTIM14Compare1(TIM_GetTIM14Capture1()+1); // 使能PWM输出，输出1M/500=2kHZ的PWM波形，占空比为当前计数值+1 
        if(TIM_GetTIM14Capture1()==300)TIM_SetTIM14Compare1(0); // 如果计数值达到300，则关闭PWM输出        
        if(TIM5CH1_CAPTURE_STA&0X80)        // 成功捕获到了一次高电平
        {
            temp = TIM5CH1_CAPTURE_STA&0X3F; 
            temp *= 0XFFFFFFFF;                 // 溢出时间总和
            temp += TIM5CH1_CAPTURE_VAL;    // 得到总的高电平时间
            printf("HIGH:%lld us\r\n",temp);// 打印总的高点平时间
            TIM5CH1_CAPTURE_STA = 0;        // 开启下一次捕获
        }
    }
}
```

## 3. 小结

如果整个看完依旧很迷的话，看下面这个图就很容易理解了

![屏幕截图 2024 10 03 144616](https://img.picgo.net/2024/10/03/-2024-10-03-1446165d9bbba6fe3c53a5.png)

首先我们是捕获的上升沿，对应图的0~t1，对应的代码：

```c
else //还未开始,第一次捕获上升沿
{    
    TIM5CH1_CAPTURE_STA = 0; // 清空
    TIM5CH1_CAPTURE_VAL = 0;
    TIM5CH1_CAPTURE_STA|=0X40;// 标记捕获到了上升沿
    __HAL_TIM_DISABLE(&TIM5_Handler); // 关闭定时器 5
    __HAL_TIM_SET_COUNTER(&TIM5_Handler,0);
    TIM_RESET_CAPTUREPOLARITY(&TIM5_Handler, TIM_CHANNEL_1); //一定要先清除原来的设置！！
    TIM_SET_CAPTUREPOLARITY(&TIM5_Handler,TIM_CHANNEL_1,TIM_ICPOLARITY_FALLING);
    //定时器 5 通道 1 设置为下降沿捕获
    __HAL_TIM_ENABLE(&TIM5_Handler); // 使能定时器 5
}
```

代码中，我们给了一个标志位说明已经捕获到上升沿，可以进入下一个阶段了，并且初始化定时器，定时器之前我们已经配置好了，为向上计数，向上计数可能到导致问题，那么就是可能产生溢出，那么对应的我们也有定时器计数溢出函数进行处理：

```c
//更新中断（溢出）发生时执行
{    
    if((TIM5CH1_CAPTURE_STA&0X80)==0)//还未成功捕获
    {
        if(TIM5CH1_CAPTURE_STA&0X40)//已经捕获到高电平了
        {
            if((TIM5CH1_CAPTURE_STA&0X3F)==0X3F)//高电平太长了
            {
                TIM5CH1_CAPTURE_STA|=0X80; //标记成功捕获了一次
                TIM5CH1_CAPTURE_VAL=0XFFFFFFFF;
            }
            else 
                TIM5CH1_CAPTURE_STA++;
        }
    } 
}
```

![屏幕截图 2024 10 03 145521](https://img.picgo.net/2024/10/03/-2024-10-03-1455218d9d7c41f77695d2.png)

上升沿和溢出处理我们都已经解决了，下面还有一个下降沿，也就是t1~t2，我们计算高电平的时间就是利用这段时间来处理的：

```c
if(TIM5CH1_CAPTURE_STA&0X40) //捕获到一个下降沿
{    
    TIM5CH1_CAPTURE_STA|=0X80; // 标记成功捕获到一次高电平脉宽
    TIM5CH1_CAPTURE_VAL=HAL_TIM_ReadCapturedValue(&TIM5_Handler,TIM_CHANNEL_1);//获取当前的捕获值.
    TIM_RESET_CAPTUREPOLARITY(&TIM5_Handler,TIM_CHANNEL_1); //一定要先清除原来的设置！！
    TIM_SET_CAPTUREPOLARITY(&TIM5_Handler,TIM_CHANNEL_1,TIM_ICPOLARITY_RISING);//配置 TIM5 通道 1 上升沿捕获
```

当我们捕获到一个下降沿后，获取当前的捕获值，然后再初始化定时器为向上计数并且上升沿捕获，开启下一轮。

---

如果还是不理解的，可以看看下面的简化版本：

```c
#include "stm32f4xx_hal.h"  // 根据你的具体MCU修改此头文件

TIM_HandleTypeDef htim2; // 定义定时器句柄

// 状态变量
volatile uint32_t captureStart = 0; // 存储捕获开始时间
volatile uint32_t captureEnd = 0;   // 存储捕获结束时间
volatile uint8_t capturing = 0;     // 捕获状态标志
volatile uint32_t overflowCount = 0;// 溢出计数

void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_TIM2_Init(void);

int main(void) {
    HAL_Init();          // 初始化HAL库
    SystemClock_Config();// 配置系统时钟
    MX_GPIO_Init();      // 初始化GPIO（如果需要）
    MX_TIM2_Init();      // 初始化定时器

    // 启动定时器的输入捕获中断
    HAL_TIM_IC_Start_IT(&htim2, TIM_CHANNEL_1);
    // 启动定时器的溢出中断
    HAL_TIM_Base_Start_IT(&htim2);
    while (1) {
        // 主循环可以放其他代码
    }
}

// 输入捕获回调函数
void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim) 
{
    if (htim->Instance == TIM2) { // 确保是TIM2的中断
        if (!capturing) {         // 如果当前不在捕获状态
            // 捕获开始
            captureStart = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1); // 读取开始时间
            capturing = 1;         // 标记为正在捕获
        } else {                   // 如果已经在捕获状态
            // 捕获结束
            captureEnd = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);   // 读取结束时间
            capturing = 0;         // 恢复状态
            // 计算高电平时间（单位为计数）
            uint32_t highTime;
            if (captureEnd >= captureStart) {
                highTime = captureEnd - captureStart + (overflowCount * (htim2.Init.Period + 1));
            } else {
                highTime = (htim2.Init.Period + 1 - captureStart) + captureEnd + (overflowCount * (htim2.Init.Period + 1));
            }
            // 此处可以根据需要对计算的高电平时间进行处理
            // 例如：存储、显示等
        }
    }
}

// 定时器溢出回调函数
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {
    if (htim->Instance == TIM2) { // 确保是TIM2的溢出中断
        overflowCount++;           // 溢出计数加1
    }
}

// 初始化定时器
static void MX_TIM2_Init(void) {
    __HAL_RCC_TIM2_CLK_ENABLE(); // 使能TIM2时钟

    TIM_IC_InitTypeDef sConfigIC = {0}; // 输入捕获配置结构体

    htim2.Instance = TIM2; // 选择TIM2
    htim2.Init.Prescaler = 83; // 将定时器时钟设置为1us（84MHz / 84 = 1MHz）
    htim2.Init.CounterMode = TIM_COUNTERMODE_UP; // 向上计数模式
    htim2.Init.Period = 0xFFFF; // 最大计数值
    htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1; // 时钟分频
    HAL_TIM_Base_Init(&htim2); // 初始化定时器基础功能

    // 配置输入捕获信道
    sConfigIC.ICPolarity = TIM_ICPOLARITY_RISING; // 捕获上升沿
    sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI; // 直接连接输入
    sConfigIC.ICPrescaler = TIM_ICPSC_DIV1; // 不分频
    sConfigIC.ICFilter = 0; // 无滤波
    HAL_TIM_IC_ConfigChannel(&htim2, &sConfigIC, TIM_CHANNEL_1); // 配置TIM2通道1
}

// 其他必要的初始化函数，如SystemClock_Config和MX_GPIO_Init
```

1. **状态变量**：
   
   - `volatile uint32_t overflowCount`：用于记录定时器溢出的次数。

2. **输入捕获回调** (`HAL_TIM_IC_CaptureCallback`)：
   
   - 在捕获到上升沿时，记录 `captureStart`。
   - 在捕获到下降沿时，记录 `captureEnd`，并根据当前溢出的次数计算高电平持续时间。
   - 使用条件判断处理可能的计数器溢出情况。

3. **定时器溢出回调** (`HAL_TIM_PeriodElapsedCallback`)：
   
   - 每当定时器溢出时，该函数会被调用，增加溢出计数器。

4. **定时器初始化** (`MX_TIM2_Init`)：
   
   - 配置定时器为上升沿捕获模式，并设置相关参数。

---

2024.10.3 第一次修订，后期不再维护
