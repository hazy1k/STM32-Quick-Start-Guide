# 第六章 独立看门狗实验

## 1. 硬件设计

本实验使用到的硬件资源有：

- 指示灯DS0

- KEY_UP按键

- 独立看门狗

前面两个在之前都有介绍，而独立看门狗实验的核心是在 STM32F4 内部进行，并不需要外部电路。但是考虑到指示当前状态和喂狗等操作，我们需要 2 个 IO 口，一个用来输入喂狗信号，另外一个用来指示程序是否重启。喂狗我们采用板上的 KEY_UP 键来操作，而程序重启，则是通过 DS0 来指示的。

## 2. 软件设计

- 看门狗函数

```c
IWDG_HandleTypeDef IWDG_Handler; // 独立看门狗句柄
// 初始化独立看门狗
// prer:分频数:IWDG_PRESCALER_4 ~ IWDG_PRESCALER_256
// rlr:自动重装载值,0~0XFFF.
// 时间计算(大概):Tout=((4*2^prer)*rlr)/32 (ms).
void IWDG_Init(u8 prer,u16 rlr)
{
    IWDG_Handler.Instance = IWDG;      // 选择IWDG外设
    IWDG_Handler.Init.Prescaler = prer;// 设置IWDG分频系数
    IWDG_Handler.Init.Reload = rlr;    // 重装载值
    HAL_IWDG_Init(&IWDG_Handler);      // 初始化IWDG,默认会开启独立看门狗    
}

// 喂独立看门狗
void IWDG_Feed(void)
{   
    HAL_IWDG_Refresh(&IWDG_Handler); // 喂狗
}
```

该函数有 2 个参数，分别用来设置预分频数与重装载寄存器的值。通过这两个参数，就可以大概知道看门狗复位的时间周期为多少了。其计算方式上面有详细的介绍，这里不再多说了。

void IWDG_Feed(void)函数，该函数用来喂狗，因为 STM32 的喂狗只需要向关键字寄存器写入 0XAAAA 即可,也就是调用库函数 HAL_IWDG_Refresh，所以这个函数也是很简单的。

- 主函数看门狗部分

```c
    IWDG_Init(IWDG_PRESCALER_64, 500);// 看门狗初始化,预分频数为64,重载值为500,溢出时间为1s    
    LED0 = 0; // LED0 熄灭
    while(1)
    {    
        if(KEY_Scan(0) == WKUP_PRES) // 如果WK_UP按下，喂狗
        {
            IWDG_Feed();// 喂狗
        }
        delay_ms(10); 
    }
}
```

## 3. 小结

独立看门狗比较简单，没什么好说的，实际上你可以理解为一个向下递减的定时器，只不够多了一个监控功能，如果不能在定时器规定的时间内及时喂狗，那么看门狗就会代替你复位整个程序。独立看门狗配置也不麻烦，参考下面这个结构体：

```c
void IWDG_Init(u8 prer,u16 rlr)
{
    IWDG_Handler.Instance = IWDG;      // 选择IWDG外设
    IWDG_Handler.Init.Prescaler = prer;// 设置IWDG分频系数
    IWDG_Handler.Init.Reload = rlr;    // 重装载值
    HAL_IWDG_Init(&IWDG_Handler);      // 初始化IWDG,默认会开启独立看门狗    
}
```

---

2024.9.29 第一次修订，后期不再维护


