# 第一章 跑马灯实验

## 1. 导入

任何一个单片机， 最简单的外设莫过于 IO 口的高低电平控制了，本章将通过一个经典的跑马灯程序，带大家开启 STM32F4 之旅， 通过本章的学习， 你将了解到 STM32F4 的 IO 口作为输出使用的方法。 在本章中， 我们将通过代码控制 ALIENTEK 探索者 STM32F4 开发板上的两个 LED： DS0 和 DS1 交替闪烁，实现类似跑马灯的效果。

## 2. STM32F4 IO简介

首先要提一下，在 HAL 库中， GPIO 端口操作对应的 HAL 库函数函数以及相关定义在文件 stm32f4xx_hal_gpio.h 和 stm32f4xx_hal_gpio.c 中。

相对于 STM32F1 来说， STM32F4 的 GPIO 设置显得更为复杂，也更加灵活，尤其是复用功能部分，比 STM32F1 改进了很多，使用起来更加方便。

STM32F4 每组通用 I/O 端口包括 4 个 32 位配置寄存器（MODER、 OTYPER、 OSPEEDR和 PUPDR）、 2 个 32 位数据寄存器（IDR 和 ODR）、 1 个 32 位置位/复位寄存器 (BSRR)、1 个 32 位锁定寄存器 (LCKR) 和 2 个 32 位复用功能选择寄存器（AFRH 和 AFRL）等。

这样， STM32F4 每组 IO 有 10 个 32 位寄存器控制，其中常用的有 4 个配置寄存器+2 个数据寄存器+2 个复用功能选择寄存器，共 8 个，如果在使用的时候，每次都直接操作寄存器配置IO， 代码会比较多，也不容易记住，所以我们在讲解寄存器的同时会讲解使用 HAL 库函数配置 IO 的方法。

同 STM32F1 一样， STM32F4 的 IO 可以由软件配置成如下 8 种模式中的任何一种：

- 输入浮空

- 输入上拉

- 输入下拉

- 模拟输入

- 开漏输出

- 推挽输出

- 推挽式复用功能

- 开漏式复用功能

接下来我们详细介绍 IO 配置常用的 8 个寄存器： MODER、 OTYPER、 OSPEEDR、 PUPDR、 ODR、 IDR 、 AFRH 和 AFRL。同时讲解对应的库函数配置方法。

首先看 MODER 寄存器，该寄存器是 GPIO 端口模式控制寄存器，用于控制 GPIOx （STM32F4 最多有 9 组 IO，分别用大写字母表示，即 x=A/B/C/D/E/F/G/H/I，下同）的工作模式：

![](C:\Users\qiu\AppData\Roaming\marktext\images\2024-08-30-15-32-00-image.png)

该寄存器各位在复位后，一般都是 0（个别不是 0，比如 JTAG 占用的几个 IO 口），也就是默认条件下一般是输入状态的。每组 IO 下有 16 个 IO 口，该寄存器共 32 位，每 2 个位控制 1个 IO，不同设置所对应的模式见表

![](C:\Users\qiu\AppData\Roaming\marktext\images\2024-08-30-15-32-47-image.png)

该寄存器也仅用于输出模式，在输入模式（MODER[1:0]=00/11 时）下不起作用。该寄存器每 2 个位控制一个 IO 口，复位后，该寄存器值一般为 0。

然后看 PUPDR 寄存器，该寄存器用于控制 GPIOx 的上拉/下拉，该寄存器各位描述见表：

![屏幕截图 2024 08 30 153827](https://img.picgo.net/2024/08/30/-2024-08-30-153827dea0425f3b29a58d.png)

该寄存器每 2 个位控制一个 IO 口，用于设置上下拉，这里提醒大家， STM32F1 是通过 ODR寄存器控制上下拉的，而 STM32F4则由单独的寄存器 PUPDR控制上下拉，使用起来更加灵活。复位后，该寄存器值一般为 0。

前面，我们讲解了 4 个重要的配置寄存器。顾名思义，配置寄存器就是用来配置 GPIO 的相关模式和状态， 接下来我们讲解怎么在库函数初始化 GPIO 的配置。

GPIO 相 关 的 函 数 和 定 义 分 布 在 HAL 库 文 件 stm32f4xx_hal_gpio.c 和 头 文 件stm32f4xx_hal_gpio.h 文件中。

在 HAL 库开发中， 操作四个配置寄存器初始化 GPIO 是通过 GPIO 初始化函数完成：

```c
void HAL_GPIO_Init(GPIO_TypeDef *GPIOx, GPIO_InitTypeDef *GPIO_Init)
```

这个函数有两个参数，第一个参数是用来指定需要初始化的 GPIO 对应的 GPIO 组，取值范围为 GPIOA~GPIOK。第二个参数为初始化参数结构体指针，结构体类型为 GPIO_InitTypeDef。下面我们看看这个结构体的定义。首先我们打开我们光盘的跑马灯实验，然后找到 FWLib 组下面的 stm32f4xx_hal_gpio.c 文件，定位到 HAL_GPIO_Init 函数体处，选中结构体“Ctrl + F”全局搜索， 可以查看结构体的定义：

```c
typedef struct
{        
    uint32_t Pin;
    uint32_t Mode;
    uint32_t Pull;
    uint32_t Speed;
    uint32_t Alternate;
}GPIO_InitTypeDef;
```

下面我们通过一个 GPIO 初始化实例来讲解这个结构体的成员变量的含义。通过初始化结构体初始化 GPIO 的常用格式是：

```c
GPIO_Initure.Pin=GPIO_PIN_9|GPIO_PIN_10;  // PF9,10
GPIO_Initure.Mode=GPIO_MODE_OUTPUT_PP;    // 推挽输出
GPIO_Initure.Pull=GPIO_PULLUP;            // 上拉
GPIO_Initure.Speed=GPIO_SPEED_HIGH;       // 高速
HAL_GPIO_Init(GPIOF,&GPIO_Initure);
```

上面代码的意思是设置 GPIOF 的第 9 和 10 端口为推挽输出模式，同时速度为 100M，上拉。

从上面初始化代码可以看出，结构体 GPIO_InitStructure 的第一个成员变量 Pin 用来设置是要初始化哪个或者哪些 IO 口，这个很好理解；第二个成员变量 Mode 是用来设置对应 IO 端口的输出输入端口模式， 这个值实际就是配置我们前面讲解的 GPIOx 的 MODER 寄存器的值。 在MDK 中是通过宏定义来定义的，我们只需要选择对应的值即可：

```c
#define GPIO_MODE_INPUT 0x00000000U
#define GPIO_MODE_OUTPUT_PP 0x00000001U
#define GPIO_MODE_OUTPUT_OD 0x00000011U
……省略部分宏定义
#define GPIO_MODE_EVT_RISING_FALLING 0x10320000U
```

例如GPIO_MODE_INPUT是输入模式， GPIO_MODE_OUTPUT_PP是推挽输出模式等等，根据实际需求来选择。

第三个参数 Pull 用来设置 IO 口的上下拉，实际上就是设置 GPIO 的 PUPDR 寄存器的值。同样通过宏定义来定义的：

```c
#define GPIO_NOPULL 0x00000000U
#define GPIO_PULLUP 0x00000001U
#define GPIO_PULLDOWN 0x00000002U
```

这三个值的意思很好理解， GPIO_NOPULL 为不使用上下拉， GPIO_PULLUP 为上拉， GPIO_PULLDOWN 为下拉。我们根据我们 需要设置相应的值即可。

第四个参数 GPIO_Speed 是 IO 口输出速度设置，有四个可选值。实际上这就是配置的 GPIO对应的 OSPEEDR 寄存器的值。 在 MDK 中同样是宏定义来定义的：

```c
#define GPIO_SPEED_FREQ_LOW 0x00000000U
#define GPIO_SPEED_FREQ_MEDIUM 0x00000001U
#define GPIO_SPEED_FREQ_HIGH 0x00000002U
#define GPIO_SPEED_FREQ_VERY_HIGH 0x00000003U
```

看完了 GPIO 的参数配置寄存器，接下来我们看看 GPIO 输入输出电平控制相关的寄存器。

首先我们看 ODR 寄存器，该寄存器用于控制 GPIOx 的输出:

![屏幕截图 2024 08 30 161839](https://img.picgo.net/2024/08/30/-2024-08-30-161839cbe78898f2001984.png)

该寄存器用于设置某个 IO 输出低电平(ODRy=0)还是高电平(ODRy=1)，该寄存器也仅在输出模式下有效，在输入模式（MODER[1:0]=00/11 时）下不起作用。

在 HAL 库 中 设 置 ODR 寄 存 器 的 值 来 控 制 IO 口 的 输 出 状 态 是 通 过 函 数HAL_GPIO_WritePin 来实现的：

```c
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
```

使用实例如下：

```c
HAL_GPIO_WritePin(GPIOF, GPIO_PIN_9, GPIO_PIN_SET);
```

接下来我们看看 IDR 寄存器，该寄存器用于读取 GPIOx 的输入:

![](C:\Users\qiu\AppData\Roaming\marktext\images\2024-08-30-16-21-19-image.png)

该寄存器用于读取某个 IO 的电平，如果对应的位为 0(IDRy=0)，则说明该 IO 输入的是低电平，如果是 1(IDRy=1)，则表示输入的是高电平。 库函数相关函数为：

```c
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
```

函数是用来读取一组 IO 口的一个输入电平。 比如我们要读取 GPIOF.5 的输入电平，方法为

```c
HAL_GPIO_ReadPin (GPIOF, GPIO_Pin_5);
```

接下来我们看看 32 位置位/复位寄存器 (BSRR)， 顾名思义，这个寄存器是用来置位或者复位 IO 口， 该寄存器和 ODR 寄存器具有类似的作用，都可以用来设置 GPIO 端口的输出位是1 还是 0。寄存器描述如下：

![](C:\Users\qiu\AppData\Roaming\marktext\images\2024-08-30-16-24-38-image.png)

对于低 16 位（0-15），我们往相应的位写 1，那么对应的 IO 口会输出高电平，往相应的位写 0，对 IO 口没有任何影响。高 16 位（16-31）作用刚好相反，对相应的位写 1 会输出低电平，写 0没有任何影响。也就是说，对于 BSRR 寄存器，你写 0 的话，对 IO 口电平是没有任何影响的。我们要设置某个 IO 口电平，只需要为相关位设置为 1 即可。而 ODR 寄存器，我们要设置某个IO 口电平，我们首先需要读出来 ODR 寄存器的值，然后对整个 ODR 寄存器重新赋值来达到设置某个或者某些 IO 口的目的，而 BSRR 寄存器，我们就不需要先读，而是直接设置。

BSRR 寄存器使用方法如下：

```c
GPIOA->BSRR=1<<1;      //设置 GPIOA.1 为高电平
GPIOA->BSRR=1<<（16+1） //设置 GPIOA.1 为低电平;
```

最后我们来看看 2 个 32 位复用功能选择寄存器（AFRH 和 AFRL），这两个寄存器是用来设置 IO 口的复用功能的。

GPIO 相关的函数我们先讲解到这里。虽然 IO 操作步骤很简单，这里我们还是做个概括性的总结，操作步骤为：

1. 使能 IO 口时钟。调用函数为__HAL_RCC_GPIOF_CLK_ENABLE();

2. 初始化 IO 参数。调用函数 HAL_GPIO_Init();

3. 操作 IO。操作 IO 的方法就是上面我们讲解的方法。

## 3. 硬件设计

本章用到的硬件只有 LED（DS0 和 DS1）。其电路在 ALIENTEK 探索者 STM32F4 开发板上默认是已经连接好了的。 DS0 接 PF9， DS1 接 PF10。所以在硬件上不需要动任何东西。

![](C:\Users\qiu\AppData\Roaming\marktext\images\2024-08-30-16-26-57-image.png)

## 4. 软件设计

```c
#include "sys.h"
#include "delay.h"
#include "usart.h"
#include "led.h"

int main(void)
{ 
    HAL_Init();                        //初始化HAL库    
    Stm32_Clock_Init(336,8,2,7);      //设置时钟,168Mhz
    delay_init(168);                   //初始化延时函数
    LED_Init();                        //初始化LED    

    while(1)
    {
        HAL_GPIO_WritePin(GPIOF,GPIO_PIN_9, GPIO_PIN_RESET); // LED0对应引脚PF9拉低，亮，等同于LED0(0)
        HAL_GPIO_WritePin(GPIOF,GPIO_PIN_10, GPIO_PIN_SET);  // LED1对应引脚PF10拉高，灭，等同于LED1(1)
        delay_ms(500);                                         // 延时500ms
        HAL_GPIO_WritePin(GPIOF,GPIO_PIN_9,GPIO_PIN_SET);    // LED0对应引脚PF9拉高，灭，等同于LED0(1)
        HAL_GPIO_WritePin(GPIOF,GPIO_PIN_10,GPIO_PIN_RESET); // LED1对应引脚PF10拉低，亮，等同于LED1(0)
        delay_ms(500);                                       // 延时500ms 
    }
}
```

代码包含了#include "led.h"这句，使得 LED0、 LED1、 LED_Init 等能在 main()函数里被调用。这里我们需要重申的是，在 HAL 库中，系统在启动的时候会调用 system_stm32f4xx.c 中的函数SystemInit()对系统时钟进行初始化，在时钟初始化完毕之后会调用 main()函数。 所以我们不需要再在 main()函数中调用 SystemInit()函数。当然如果有需要重新设置时钟系统，可以写自己的时钟设置代码， SystemInit()只是将时钟系统初始化为默认状态。

main()函数非常简单，先调用 delay_init()初始化延时，接着就是调用 LED_Init()来初始化GPIOF.9 和 GPIOF.10 为输出。最后在死循环里面实现 LED0 和 LED1 交替闪烁，间隔为 500ms。

上面是通过库函数来实现的 IO 操作，我们也可以修改 main()函数，直接通过位带操作达到同样的效果，大家不妨试试。 位带操作的代码如下：

```c
int main(void)
{    
    HAL_Init(); //初始化 HAL 库
    Stm32_Clock_Init(336,8,2,7); //设置时钟,168Mhz
    delay_init(168); //初始化延时函数
    LED_Init(); //初始化 LED
    while(1)
    {
        LED0 = 0; //LED0 亮
        LED1 = 1; //LED1 灭
        delay_ms(500);
        LED0 = 1; //LED0 灭
        LED1 = 0; //LED1 亮
        delay_ms(500);
    }
}
```

当然我们也可以通过直接操作相关寄存器的方法来设置 IO，我们只需要将主函数修改为如下内容：

```c
int main(void)
{ 
    HAL_Init();                        //初始化HAL库    
    Stm32_Clock_Init(336,8,2,7);      //设置时钟,168Mhz
    delay_init(168);                   //初始化延时函数
    LED_Init();                        //初始化LED    

    while(1)
    {
      GPIOF->BSRR =GPIO_PIN_9;         //LED0亮
      GPIOF->BSRR = GPIO_PIN_10<<16;     //LED1灭
      delay_ms(500);
      GPIOF->BSRR = GPIO_PIN_9<<16;     //LED0灭
      GPIOF->BSRR = GPIO_PIN_10;         //LED1亮
      delay_ms(500);
     }
```

## 5. 小结

作为我们第一个HAL库的十一程序，我们有必要解释的详细一点，并且与标准库进行一下比较：

### 代码解释

1. **头文件引入**

```c
#include "sys.h"
#include "delay.h"
#include "usart.h"
#include "led.h"
```

- `sys.h` 可能包含了系统级的初始化函数，例如时钟配置。
- `delay.h` 提供了延时函数的声明。
- `usart.h` 可能包含了串口通信相关的函数声明（在这段代码中并未使用）。
- `led.h` 包含了LED控制相关的函数声明。
2. 主函数

```c
int main(void)
{ 
    HAL_Init();                       // 初始化HAL库
    Stm32_Clock_Init(336,8,2,7);      // 设置时钟，168MHz
    delay_init(168);                  // 初始化延时函数
    LED_Init();                       // 初始化LED    

    while(1)
    {
        HAL_GPIO_WritePin(GPIOF,GPIO_PIN_9, GPIO_PIN_RESET); // LED0对应引脚PF9拉低，亮，等同于LED0(0)
        HAL_GPIO_WritePin(GPIOF,GPIO_PIN_10, GPIO_PIN_SET);  // LED1对应引脚PF10拉高，灭，等同于LED1(1)
        delay_ms(500);                                         // 延时500ms
        HAL_GPIO_WritePin(GPIOF,GPIO_PIN_9,GPIO_PIN_SET);    // LED0对应引脚PF9拉高，灭，等同于LED0(1)
        HAL_GPIO_WritePin(GPIOF,GPIO_PIN_10,GPIO_PIN_RESET); // LED1对应引脚PF10拉低，亮，等同于LED1(0)
        delay_ms(500);                                       // 延时500ms 
    }
}
```

- `HAL_Init()`：初始化 STM32 的 HAL 库，这为后续的 HAL 函数调用做好准备。
- `Stm32_Clock_Init(336,8,2,7)`：配置系统时钟，可能将系统时钟设置为 168 MHz。
- `delay_init(168)`：初始化延时函数，设置延时时钟源。
- `LED_Init()`：初始化 LED 控制相关的 GPIO 引脚。
- `while(1)`：主循环中，LED0 和 LED1 交替闪烁，每个状态持续 500ms。

### 标准库改造

- 主函数

```c
#include "stm32f4xx.h"  // 包含 STM32F4 系列微控制器的头文件
#include "delay.h"      // 包含延时函数的头文件

// LED 引脚初始化函数
void LED_Init(void) {
    GPIO_InitTypeDef GPIO_InitStruct;  // 定义 GPIO 初始化结构体

    // 使能 GPIOF 时钟
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF, ENABLE);

    // 配置 PF9 和 PF10 为推挽输出
    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_10; // 选择 PF9 和 PF10 引脚
    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_OUT;           // 设置为输出模式
    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;       // 输出速度设置为 50 MHz
    GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;          // 输出类型设置为推挽输出
    GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_NOPULL;        // 不使用上下拉电阻
    GPIO_Init(GPIOF, &GPIO_InitStruct);                  // 初始化 GPIOF
}

int main(void) {
    // 系统时钟初始化
    SystemInit();

    // 延时函数初始化，设置系统时钟频率（假设为 168 MHz）
    delay_init(168);

    // LED 初始化
    LED_Init();

    while (1) {
        // 点亮 PF9 (LED0)
        GPIO_SetBits(GPIOF, GPIO_Pin_9);
        // 熄灭 PF10 (LED1)
        GPIO_ResetBits(GPIOF, GPIO_Pin_10);
        delay_ms(500);  // 延时 500 毫秒

        // 熄灭 PF9 (LED0)
        GPIO_ResetBits(GPIOF, GPIO_Pin_9);
        // 点亮 PF10 (LED1)
        GPIO_SetBits(dIOF, GPIO_Pin_10);
        delay_ms(500);  // 延时 500 毫秒
    }
}
```

- delay.c

```c
#include "delay.h"  // 包含延时函数的头文件

// 延时计数变量
static __IO uint32_t TimingDelay;

// 延时函数初始化
void delay_init(uint8_t SYSCLK) {
    // 配置 SysTick 定时器，用于产生毫秒级别的延时
    if (SysTick_Config(SystemCoreClock / 1000)) {
        // 如果配置失败，可以在这里进行错误处理
        while (1);  // 进入死循环，表示错误
    }
}

// 毫秒级别的延时函数
void delay_ms(uint32_t ms) {
    TimingDelay = ms;  // 设置延时的毫秒数
    while (TimingDelay != 0);  // 等待直到计数器减少到零
}

// SysTick 中断处理函数
void SysTick_Handler(void) {
    if (TimingDelay != 0) {
        TimingDelay--;  // 每毫秒减少计数器值
    }
}

```

- delay.h

```c
#ifndef __DELAY_H
#define __DELAY_H

#include "stm32f4xx.h"  // 包含 STM32F4 系列微控制器的头文件

// 函数声明
void delay_init(uint8_t SYSCLK);   // 延时初始化函数
void delay_ms(uint32_t ms);        // 毫秒级别延时函数

#endif

```

1. **`main.c`**:
   
   - **头文件包含**: 包含了 STM32F4 系列的头文件以及延时函数的头文件。
   - **`LED_Init()`**: 使能 GPIOF 时钟，配置 PF9 和 PF10 为推挽输出模式。
   - **`main()`**: 初始化系统时钟和延时函数。进入无限循环中交替点亮和熄灭两个 LED，引脚的状态由 `GPIO_SetBits()` 和 `GPIO_ResetBits()` 控制。

2. **`delay.c`**:
   
   - **`delay_init()`**: 配置 SysTick 定时器以每毫秒产生一次中断。`SysTick_Config()` 函数根据系统时钟频率进行配置。
   - **`delay_ms()`**: 根据 `TimingDelay` 变量的值进行延时，直到 `TimingDelay` 减少到零。
   - **`SysTick_Handler()`**: SysTick 中断处理程序，每毫秒减少 `TimingDelay` 变量的值。

3. **`delay.h`**:
   
   - 定义了延时函数的声明，确保 `delay.c` 文件中的函数可以被其他文件引用。


