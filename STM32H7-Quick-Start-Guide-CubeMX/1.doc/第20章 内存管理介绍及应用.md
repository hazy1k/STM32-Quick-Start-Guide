# ç¬¬äºŒåç«  å†…å­˜ç®¡ç†ä»‹ç»åŠåº”ç”¨

## 1. å†…å­˜ç®¡ç†ç®€ä»‹

å†…å­˜ç®¡ç†æ˜¯ **STM32H750VBT6** ç³»ç»Ÿä¸­å¯¹**ç‰‡ä¸Šå­˜å‚¨èµ„æºè¿›è¡Œè§„åˆ’ã€åˆ†é…ã€ä¿æŠ¤å’Œä¼˜åŒ–**çš„æ ¸å¿ƒæœºåˆ¶ï¼Œæ¶‰åŠ **Flashã€SRAMã€DMAä¸“ç”¨å†…å­˜ã€ç¼“å­˜ï¼ˆCacheï¼‰** ä»¥åŠ **å¤–éƒ¨å­˜å‚¨ï¼ˆQSPI/FMCï¼‰** çš„ååŒä½¿ç”¨ã€‚è‰¯å¥½çš„å†…å­˜ç®¡ç†å¯æå‡ç³»ç»Ÿæ€§èƒ½ã€å¢å¼ºå®‰å…¨æ€§ã€é™ä½åŠŸè€—ï¼Œå¹¶æ”¯æŒå¤æ‚åº”ç”¨ï¼ˆå¦‚RTOSã€å›¾å½¢ç•Œé¢ã€éŸ³é¢‘å¤„ç†ï¼‰çš„ç¨³å®šè¿è¡Œã€‚

> ğŸ” **æ ¸å¿ƒå®šä½**ï¼š
> 
> - **å†…å­˜ç®¡ç† â‰  ç®€å•åˆ†é…æ•°ç»„**ï¼Œè€Œæ˜¯**å…¨ç³»ç»Ÿå­˜å‚¨èµ„æºçš„â€œæˆ˜ç•¥è°ƒåº¦â€**
> - æ¶‰åŠ **é“¾æ¥è„šæœ¬ã€å¯åŠ¨ä»£ç ã€MPUã€Cacheã€DMAã€å †æ ˆä¼˜åŒ–**
> - æ˜¯å®ç° **å¤šä»»åŠ¡ã€å®æ—¶æ€§ã€å®‰å…¨æ€§** çš„åŸºç¡€
> - æ”¯æŒ **XIPï¼ˆä»£ç æ‰§è¡Œï¼‰ã€é›¶æ‹·è´ã€å†…å­˜ä¿æŠ¤**

---

### 1.1 STM32H750VBT6 å†…å­˜æ¶æ„æ€»è§ˆ

| **å†…å­˜ç±»å‹**           | **èµ·å§‹åœ°å€**      | **å¤§å°**   | **ç”¨é€”**        | **è®¿é—®é€Ÿåº¦**      |
| ------------------ | ------------- | -------- | ------------- | ------------- |
| **å†…éƒ¨Flashï¼ˆè™šæ‹Ÿï¼‰**    | `0x0800 0000` | 128 KB   | ç¨‹åºä»£ç ã€å¸¸é‡       | 480 MHzï¼ˆ0 WSï¼‰ |
| **ç³»ç»Ÿå­˜å‚¨åŒº**          | `0x1FF0 9800` | 30 KB    | ST Bootloader | åªè¯»            |
| **OTP åŒºåŸŸ**         | `0x1FF0 F400` | 512 B    | å”¯ä¸€IDã€å¯†é’¥       | ä¸€æ¬¡æ€§å†™å…¥         |
| **D1åŸŸ SRAMï¼ˆITCMï¼‰** | `0x0000 0000` | 64 KB    | é«˜é€Ÿä»£ç /æ•°æ®       | CPU ç›´æ¥è®¿é—®      |
| **D1åŸŸ SRAMï¼ˆDTCMï¼‰** | `0x2000 0000` | 128 KB   | å˜é‡ã€å †æ ˆ         | ä¸CPUåŒé¢‘        |
| **D2åŸŸ SRAM**       | `0x3000 0000` | 512 KB   | å¤–è®¾ç¼“å†²ã€DMA      | é«˜å¸¦å®½           |
| **D3åŸŸ SRAM**       | `0x3800 0000` | 32 KB    | ä½åŠŸè€—åŸŸæ•°æ®        | Stopæ¨¡å¼å¯ç”¨      |
| **QSPI Flash**     | `0x9000 0000` | 8â€“128 MB | å¤§å®¹é‡ä»£ç /èµ„æº      | XIP æ¨¡å¼å¯æ‰§è¡Œ     |
| **FMC PSRAM**      | `0x6000 0000` | 1â€“8 MB   | å›¾å½¢ç¼“å†²ã€å¤§æ•°ç»„      | å¯å˜æ—¶åº          |

ğŸ“Œ **å…³é”®ç‰¹æ€§**ï¼š

- **ä¸‰åŸŸæ¶æ„**ï¼ˆD1/D2/D3ï¼‰ï¼šæ”¯æŒä¸åŒåŠŸè€—ä¸æ€§èƒ½éœ€æ±‚
- **ITCM/DTCM**ï¼šç´§è€¦åˆå†…å­˜ï¼Œ0 ç­‰å¾…çŠ¶æ€ï¼Œé€‚åˆé«˜é¢‘ä»£ç 
- **QSPI è™šæ‹ŸFlash**ï¼šH750 çš„â€œå†…éƒ¨Flashâ€å®ä¸ºå°è£…å†…QSPI Flash
- **ART Accelerator**ï¼šè‡ªé€‚åº”å®æ—¶åŠ é€Ÿå™¨ï¼Œå®ç° Flash 0 ç­‰å¾…çŠ¶æ€æ‰§è¡Œ

---

### 1.2 å†…å­˜æ˜ å°„ä¸è®¿é—®ç‰¹æ€§

#### 1.2.1 åœ°å€æ˜ å°„å…³ç³»

```mermaid
graph LR
A[CPU] --> B[ITCM: 0x00000000]
A --> C[DTCM: 0x20000000]
A --> D[D2-SRAM: 0x30000000]
A --> E[QSPI: 0x90000000]
A --> F[FMC: 0x60000000]
```

- **`0x00000000` å¯é‡æ˜ å°„**ï¼š
  
  - é»˜è®¤æŒ‡å‘ **å†…éƒ¨Flash**ï¼ˆå¯åŠ¨åè·³è½¬ï¼‰
  - å¯é‡æ˜ å°„åˆ° **SRAM**ï¼ˆç”¨äºè°ƒè¯•æˆ–Bootloaderï¼‰

- **è®¿é—®æƒé™æ§åˆ¶**ï¼š
  
  - **ITCM**ï¼šä»… CPU è®¿é—®ï¼Œä¸å¯è¢« DMA ä½¿ç”¨
  - **DTCM/D2/D3 SRAM**ï¼šå¯è¢« CPU å’Œ DMA å…±äº«
  - **QSPI/FMC**ï¼šCPU å¯è¯»ï¼ŒDMA å¯é€šè¿‡ FMC/QSPI æ§åˆ¶å™¨è®¿é—®

---

### 1.3 å†…å­˜ç®¡ç†æ ¸å¿ƒæœºåˆ¶

#### 1.3.1 é“¾æ¥è„šæœ¬ï¼ˆLinker Scriptï¼‰

ç”¨äºå®šä¹‰ **ä»£ç ã€æ•°æ®ã€å †ã€æ ˆ** çš„å­˜æ”¾ä½ç½®ï¼Œæ˜¯å†…å­˜ç®¡ç†çš„â€œè“å›¾â€ã€‚

**ç¤ºä¾‹ï¼š`STM32H750VBTx_FLASH.ld` ç‰‡æ®µ**

```c
MEMORY
{
  DTCMRAM (xrw) : ORIGIN = 0x20000000, LENGTH = 128K
  RAM (xrw)     : ORIGIN = 0x30000000, LENGTH = 512K
  ITCMRAM (xrw) : ORIGIN = 0x00000000, LENGTH = 64K
  FLASH (rx)    : ORIGIN = 0x08000000, LENGTH = 128K
  QSPI (rx)     : ORIGIN = 0x90000000, LENGTH = 8M
}

SECTIONS
{
  .text :
  {
    *(.text)
    *(.text*) 
  } > FLASH

  .qspi_func :
  {
    *(.qspi_section)
  } > QSPI

  .data : 
  {
    *(.data)
  } > DTCMRAM

  .stack : 
  {
    . = ALIGN(8);
    _estack = 0x20020000; /* DTCM æœ«å°¾ */
    . = ORIGIN(RAM) + LENGTH(RAM);
    _heap_end = .;
  } > RAM
}
```

âœ… **ä½¿ç”¨æ–¹æ³•**ï¼š

- å°†å…³é”®å‡½æ•°æ”¾å…¥ QSPIï¼š
  
  ```c
  void __attribute__((section(".qspi_section"))) LargeFunction(void);
  ```

- å°†é«˜é¢‘å‡½æ•°æ”¾å…¥ ITCMï¼š
  
  ```c
  void __attribute__((section(".itcm_text"))) FastISR(void);
  ```

---

#### 1.3.2 å †æ ˆç®¡ç†

| **æ ˆï¼ˆStackï¼‰**      | **å †ï¼ˆHeapï¼‰**           |
| ----------------- | --------------------- |
| å­˜å‚¨å±€éƒ¨å˜é‡ã€å‡½æ•°è°ƒç”¨       | å­˜å‚¨åŠ¨æ€åˆ†é…å†…å­˜ï¼ˆmalloc/freeï¼‰ |
| ä½äº **DTCM æˆ– RAM** | ä½äº **RAM**ï¼ˆå»ºè®® D2åŸŸï¼‰    |
| å¤§å°ç”±é“¾æ¥è„šæœ¬å®šä¹‰         | å¤§å°ç”± `_heap_end` æ§åˆ¶    |
| æº¢å‡ºä¼šå¯¼è‡´å´©æºƒ           | ç¢ç‰‡åŒ–å½±å“é•¿æœŸè¿è¡Œ             |

**æ¨èé…ç½®**ï¼š

```c
_estack = 0x20020000;        /* DTCM æœ«å°¾ï¼Œæ ˆå‘ä¸‹å¢é•¿ */
_min_heap_size = 0x2000;     /* å †æœ€å° 8KB */
```

**æ ˆæº¢å‡ºæ£€æµ‹ï¼ˆä½¿ç”¨ MPUï¼‰**ï¼š

```c
// ä¿æŠ¤ä¸»æ ˆï¼ˆMSPï¼‰
MPU_Config_StackNoExec(0x20000000, 0x1000); // 4KB æ ˆï¼Œä¸å¯æ‰§è¡Œ
```

---

#### 1.3.3 MPU å†…å­˜ä¿æŠ¤ï¼ˆMemory Protection Unitï¼‰

MPU ç”¨äº**é˜²æ­¢éæ³•è®¿é—®ã€æ‰§è¡Œä¿æŠ¤ã€æƒé™éš”ç¦»**ã€‚

**å…¸å‹é…ç½®**ï¼š

```c
// ä¿æŠ¤ Flash åªè¯»
MPU_Config_RO(0x08000000, 0x0801FFFF);

// SRAM ä¸å¯æ‰§è¡Œï¼ˆé˜²ä»£ç æ³¨å…¥ï¼‰
MPU_Config_NoExec(0x20000000, 0x2001FFFF);

// å¤–è®¾åŒº Device ç±»å‹
MPU_Config_Device(0x40000000, 0x4FFFFFFF);
```

---

#### 1.3.4 Cache ç®¡ç†ï¼ˆL1 Cacheï¼‰

STM32H750VBT6 å…·æœ‰ **L1 Cache**ï¼š

- **I-Cache**ï¼š16 KB æŒ‡ä»¤ç¼“å­˜
- **D-Cache**ï¼š16 KB æ•°æ®ç¼“å­˜

**å…³é”®æ“ä½œ**ï¼š

- **å¯ç”¨ Cache**ï¼ˆé»˜è®¤å¯ç”¨ï¼‰ï¼š
  
  ```c
  SCB_EnableICache();
  SCB_EnableDCache();
  ```

- **Cache ä¸€è‡´æ€§ç»´æŠ¤**ï¼ˆDMA ä½¿ç”¨æ—¶å¿…é¡»ï¼‰ï¼š

```c
// DMA å†™å‰ï¼šæ¸…æ— æ•ˆ D-Cache
SCB_CleanInvalidateDCache();

// DMA è¯»åï¼šåˆ·æ–° D-Cache
SCB_InvalidateDCache();
```

### 1.4 å†…å­˜ç®¡ç†ç­–ç•¥å¯¹æ¯”

| **ç­–ç•¥**       | **ä¼˜ç‚¹** | **ç¼ºç‚¹** | **é€‚ç”¨åœºæ™¯**  |
| ------------ | ------ | ------ | --------- |
| **é»˜è®¤åˆ†é…**     | ç®€å•     | æ€§èƒ½ä¸å¯æ§  | å°é¡¹ç›®       |
| **é“¾æ¥è„šæœ¬åˆ†åŒº**   | ç²¾ç¡®æ§åˆ¶   | é…ç½®å¤æ‚   | å¤šæ¨¡å—ç³»ç»Ÿ     |
| **MPU ä¿æŠ¤**   | å®‰å…¨ã€é˜²æº¢å‡º | è°ƒè¯•å›°éš¾   | RTOSã€å®‰å…¨ç³»ç»Ÿ |
| **Cache ç®¡ç†** | é«˜æ€§èƒ½    | ä¸€è‡´æ€§é£é™©  | DMAã€é«˜é€Ÿå¤„ç†  |
| **å †æ ˆç›‘æ§**     | é˜²å´©æºƒ    | å ç”¨èµ„æº   | å·¥ä¸šçº§ç³»ç»Ÿ     |

> ğŸ’¡ **æœ€ä½³å®è·µ**ï¼š
> 
> - **é«˜é¢‘ä»£ç /ISR** â†’ ITCM
> - **å¤§ç¼“å†²åŒº/DMA** â†’ D2-SRAM
> - **å †æ ˆ** â†’ DTCM æˆ– D2-SRAM
> - **å¤§èµ„æºæ–‡ä»¶** â†’ QSPI Flashï¼ˆXIPï¼‰
> - **å›¾å½¢ç¼“å†²** â†’ FMC PSRAM

## 2. å†…å­˜ç®¡ç†ä½¿ç”¨ç¤ºä¾‹-STM32IDE

### 2.1 STM32Cubeé…ç½®

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://i-blog.csdnimg.cn/direct/2d12bbcf75384105a5663b03fa1609d7.png#pic_center)



### 2.2 ç”¨æˆ·ä»£ç 

```c
#include "malloc.h"

#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)   /* AC6ç¼–è¯‘å™¨ */
/* å†…å­˜æ± (64å­—èŠ‚å¯¹é½) */
static __ALIGNED(64) uint8_t mem1base[MEM1_MAX_SIZE];                                                       /* å†…éƒ¨SRAMå†…å­˜æ±  */
static __ALIGNED(64) uint8_t mem2base[MEM2_MAX_SIZE] __attribute__((section(".bss.ARM.__at_0x30000000")));  /* å†…éƒ¨SRAM1+SRAM2å†…å­˜æ±  */
static __ALIGNED(64) uint8_t mem3base[MEM3_MAX_SIZE] __attribute__((section(".bss.ARM.__at_0x38000000")));  /* å†…éƒ¨SRAM4å†…å­˜æ±  */
static __ALIGNED(64) uint8_t mem4base[MEM4_MAX_SIZE] __attribute__((section(".bss.ARM.__at_0x20000000")));  /* å†…éƒ¨DTCMå†…å­˜æ±  */
static __ALIGNED(64) uint8_t mem5base[MEM5_MAX_SIZE] __attribute__((section(".bss.ARM.__at_0x00000000")));  /* å†…éƒ¨ITCMå†…å­˜æ±  */

/* å†…å­˜ç®¡ç†è¡¨ */
static MT_TYPE mem1mapbase[MEM1_ALLOC_TABLE_SIZE];                                                       /* å†…éƒ¨SRAMå†…å­˜æ± MAP */
static MT_TYPE mem2mapbase[MEM2_ALLOC_TABLE_SIZE] __attribute__((section(".bss.ARM.__at_0x3003E000")));  /* å†…éƒ¨SRAM1+SRAM2å†…å­˜æ± MAP */
static MT_TYPE mem3mapbase[MEM3_ALLOC_TABLE_SIZE] __attribute__((section(".bss.ARM.__at_0x3800F800")));  /* å†…éƒ¨SRAM4å†…å­˜æ± MAP */
static MT_TYPE mem4mapbase[MEM4_ALLOC_TABLE_SIZE] __attribute__((section(".bss.ARM.__at_0x2001F000")));  /* å†…éƒ¨DTCMå†…å­˜æ± MAP */
static MT_TYPE mem5mapbase[MEM5_ALLOC_TABLE_SIZE] __attribute__((section(".bss.ARM.__at_0x0000F800")));  /* å†…éƒ¨ITCMå†…å­˜æ± MAP */

#elif defined(__GNUC__)   /* GCCç¼–è¯‘å™¨ */
/* å†…å­˜æ± (64å­—èŠ‚å¯¹é½) */
static uint8_t mem1base[MEM1_MAX_SIZE] __attribute__((aligned(64)));                                      /* å†…éƒ¨SRAMå†…å­˜æ±  */
static uint8_t mem2base[MEM2_MAX_SIZE] __attribute__((aligned(64))) __attribute__((section(".RAM_D2")));  /* å†…éƒ¨SRAM1+SRAM2å†…å­˜æ±  */
static uint8_t mem3base[MEM3_MAX_SIZE] __attribute__((aligned(64))) __attribute__((section(".RAM_D3")));  /* å†…éƒ¨SRAM4å†…å­˜æ±  */
static uint8_t mem4base[MEM4_MAX_SIZE] __attribute__((aligned(64))) __attribute__((section(".RAM_DTCM")));/* å†…éƒ¨DTCMå†…å­˜æ±  */
static uint8_t mem5base[MEM5_MAX_SIZE] __attribute__((aligned(64))) __attribute__((section(".RAM_ITCM")));/* å†…éƒ¨ITCMå†…å­˜æ±  */

/* å†…å­˜ç®¡ç†è¡¨ */
static MT_TYPE mem1mapbase[MEM1_ALLOC_TABLE_SIZE] __attribute__((aligned(64)));                           /* å†…éƒ¨SRAMå†…å­˜æ± MAP */
static MT_TYPE mem2mapbase[MEM2_ALLOC_TABLE_SIZE] __attribute__((aligned(64))) __attribute__((section(".RAM_D2")));  /* å†…éƒ¨SRAM1+SRAM2å†…å­˜æ± MAP */
static MT_TYPE mem3mapbase[MEM3_ALLOC_TABLE_SIZE] __attribute__((aligned(64))) __attribute__((section(".RAM_D3")));  /* å†…éƒ¨SRAM4å†…å­˜æ± MAP */
static MT_TYPE mem4mapbase[MEM4_ALLOC_TABLE_SIZE] __attribute__((aligned(64))) __attribute__((section(".RAM_DTCM")));/* å†…éƒ¨DTCMå†…å­˜æ± MAP */
static MT_TYPE mem5mapbase[MEM5_ALLOC_TABLE_SIZE] __attribute__((aligned(64))) __attribute__((section(".RAM_ITCM")));/* å†…éƒ¨ITCMå†…å­˜æ± MAP */

#else   /* AC5ç¼–è¯‘å™¨ */
/* å†…å­˜æ± (64å­—èŠ‚å¯¹é½) */
static __align(64) uint8_t mem1base[MEM1_MAX_SIZE];                                     /* å†…éƒ¨SRAMå†…å­˜æ±  */
static __align(64) uint8_t mem2base[MEM2_MAX_SIZE] __attribute__((at(0x30000000)));     /* å†…éƒ¨SRAM1+SRAM2å†…å­˜æ±  */
static __align(64) uint8_t mem3base[MEM3_MAX_SIZE] __attribute__((at(0x38000000)));     /* å†…éƒ¨SRAM4å†…å­˜æ±  */
static __align(64) uint8_t mem4base[MEM4_MAX_SIZE] __attribute__((at(0x20000000)));     /* å†…éƒ¨DTCMå†…å­˜æ±  */
static __align(64) uint8_t mem5base[MEM5_MAX_SIZE] __attribute__((at(0x00000000)));     /* å†…éƒ¨ITCMå†…å­˜æ±  */

/* å†…å­˜ç®¡ç†è¡¨ */
static MT_TYPE mem1mapbase[MEM1_ALLOC_TABLE_SIZE];                                                  /* å†…éƒ¨SRAMå†…å­˜æ± MAP */
static MT_TYPE mem2mapbase[MEM2_ALLOC_TABLE_SIZE] __attribute__((at(0x30000000 + MEM2_MAX_SIZE)));  /* å†…éƒ¨SRAM1+SRAM2å†…å­˜æ± MAP */
static MT_TYPE mem3mapbase[MEM3_ALLOC_TABLE_SIZE] __attribute__((at(0x38000000 + MEM3_MAX_SIZE)));  /* å†…éƒ¨SRAM4å†…å­˜æ± MAP */
static MT_TYPE mem4mapbase[MEM4_ALLOC_TABLE_SIZE] __attribute__((at(0x20000000 + MEM4_MAX_SIZE)));  /* å†…éƒ¨DTCMå†…å­˜æ± MAP */
static MT_TYPE mem5mapbase[MEM5_ALLOC_TABLE_SIZE] __attribute__((at(0x00000000 + MEM5_MAX_SIZE)));  /* å†…éƒ¨ITCMå†…å­˜æ± MAP */
#endif

/* å†…å­˜ç®¡ç†å‚æ•° */
const uint32_t memtblsize[SRAMBANK] = { MEM1_ALLOC_TABLE_SIZE, MEM2_ALLOC_TABLE_SIZE, MEM3_ALLOC_TABLE_SIZE,
                                        MEM4_ALLOC_TABLE_SIZE, MEM5_ALLOC_TABLE_SIZE };     /* å†…å­˜è¡¨å¤§å° */

const uint32_t memblksize[SRAMBANK] = { MEM1_BLOCK_SIZE, MEM2_BLOCK_SIZE, MEM3_BLOCK_SIZE,
                                        MEM4_BLOCK_SIZE, MEM5_BLOCK_SIZE };                 /* å†…å­˜åˆ†å—å¤§å° */

const uint32_t memsize[SRAMBANK] = { MEM1_MAX_SIZE, MEM2_MAX_SIZE, MEM3_MAX_SIZE,
                                     MEM4_MAX_SIZE, MEM5_MAX_SIZE };                        /* å†…å­˜æ€»å¤§å° */

/* å†…å­˜ç®¡ç†æ§åˆ¶å™¨ */
struct _m_mallco_dev mallco_dev =
{
    my_mem_init,                                                        /* å†…å­˜åˆå§‹åŒ– */
    my_mem_perused,                                                     /* å†…å­˜ä½¿ç”¨ç‡ */
    mem1base, mem2base, mem3base, mem4base, mem5base,                   /* å†…å­˜æ±  */
    mem1mapbase, mem2mapbase, mem3mapbase, mem4mapbase, mem5mapbase,    /* å†…å­˜ç®¡ç†çŠ¶æ€è¡¨ */
    0, 0, 0, 0, 0,                                                      /* å†…å­˜ç®¡ç†æœªå°±ç»ª */
};

/**
 * @brief       å¤åˆ¶å†…å­˜
 * @param       *des : ç›®çš„åœ°å€
 * @param       *src : æºåœ°å€
 * @param       n    : éœ€è¦å¤åˆ¶çš„å†…å­˜é•¿åº¦(å­—èŠ‚ä¸ºå•ä½)
 * @retval      æ— 
 */
void my_mem_copy(void *des, void *src, uint32_t n)
{
    uint8_t *xdes = des;
    uint8_t *xsrc = src;

    while (n--) *xdes++ = *xsrc++;
}

/**
 * @brief       è®¾ç½®å†…å­˜å€¼
 * @param       *s    : å†…å­˜é¦–åœ°å€
 * @param       c     : è¦è®¾ç½®çš„å€¼
 * @param       count : éœ€è¦è®¾ç½®çš„å†…å­˜å¤§å°(å­—èŠ‚ä¸ºå•ä½)
 * @retval      æ— 
 */
void my_mem_set(void *s, uint8_t c, uint32_t count)
{
    uint8_t *xs = s;

    while (count--) *xs++ = c;
}

/**
 * @brief       å†…å­˜ç®¡ç†åˆå§‹åŒ–
 * @param       memx : æ‰€å±å†…å­˜å—
 * @retval      æ— 
 */
void my_mem_init(uint8_t memx)
{
    uint8_t mttsize = sizeof(MT_TYPE);  /* è·å–memmapæ•°ç»„çš„ç±»å‹é•¿åº¦(uint16_t /uint32_t)*/
    my_mem_set(mallco_dev.memmap[memx], 0, memtblsize[memx] * mttsize); /* å†…å­˜çŠ¶æ€è¡¨æ•°æ®æ¸…é›¶ */
    mallco_dev.memrdy[memx] = 1;        /* å†…å­˜ç®¡ç†åˆå§‹åŒ–OK */
}

/**
 * @brief       è·å–å†…å­˜ä½¿ç”¨ç‡
 * @param       memx : æ‰€å±å†…å­˜å—
 * @retval      ä½¿ç”¨ç‡(æ‰©å¤§äº†10å€,0~1000,ä»£è¡¨0.0%~100.0%)
 */
uint16_t my_mem_perused(uint8_t memx)
{
    uint32_t used = 0;
    uint32_t i;

    for (i = 0; i < memtblsize[memx]; i++)
    {
        if (mallco_dev.memmap[memx][i]) used++;
    }

    return (used * 1000) / (memtblsize[memx]);
}

/**
 * @brief       å†…å­˜åˆ†é…(å†…éƒ¨è°ƒç”¨)
 * @param       memx : æ‰€å±å†…å­˜å—
 * @param       size : è¦åˆ†é…çš„å†…å­˜å¤§å°(å­—èŠ‚)
 * @retval      å†…å­˜åç§»åœ°å€
 *   @arg       0 ~ 0XFFFFFFFE : æœ‰æ•ˆçš„å†…å­˜åç§»åœ°å€
 *   @arg       0XFFFFFFFF     : æ— æ•ˆçš„å†…å­˜åç§»åœ°å€
 */
static uint32_t my_mem_malloc(uint8_t memx, uint32_t size)
{
    signed long offset = 0;
    uint32_t nmemb;         /* éœ€è¦çš„å†…å­˜å—æ•° */
    uint32_t cmemb = 0;     /* è¿ç»­ç©ºå†…å­˜å—æ•° */
    uint32_t i;

    if (!mallco_dev.memrdy[memx])
    {
        mallco_dev.init(memx);          /* æœªåˆå§‹åŒ–,å…ˆæ‰§è¡Œåˆå§‹åŒ– */
    }

    if (size == 0) return 0XFFFFFFFF;   /* ä¸éœ€è¦åˆ†é… */

    nmemb = size / memblksize[memx];    /* è·å–éœ€è¦åˆ†é…çš„è¿ç»­å†…å­˜å—æ•° */

    if (size % memblksize[memx]) nmemb++;

    for (offset = memtblsize[memx] - 1; offset >= 0; offset--)  /* æœç´¢æ•´ä¸ªå†…å­˜æ§åˆ¶åŒº */
    {
        if (!mallco_dev.memmap[memx][offset])
        {
            cmemb++;            /* è¿ç»­ç©ºå†…å­˜å—æ•°å¢åŠ  */
        }
        else
        {
            cmemb = 0;          /* è¿ç»­å†…å­˜å—æ¸…é›¶ */
        }

        if (cmemb == nmemb)     /* æ‰¾åˆ°äº†è¿ç»­nmembä¸ªç©ºå†…å­˜å— */
        {
            for (i = 0; i < nmemb; i++)         /* æ ‡æ³¨å†…å­˜å—éç©º */
            {
                mallco_dev.memmap[memx][offset + i] = nmemb;
            }

            return (offset * memblksize[memx]); /* è¿”å›åç§»åœ°å€ */
        }
    }

    return 0XFFFFFFFF;  /* æœªæ‰¾åˆ°ç¬¦åˆåˆ†é…æ¡ä»¶çš„å†…å­˜å— */
}

/**
 * @brief       é‡Šæ”¾å†…å­˜(å†…éƒ¨è°ƒç”¨)
 * @param       memx   : æ‰€å±å†…å­˜å—
 * @param       offset : å†…å­˜åœ°å€åç§»
 * @retval      é‡Šæ”¾ç»“æœ
 *   @arg       0, é‡Šæ”¾æˆåŠŸ;
 *   @arg       1, é‡Šæ”¾å¤±è´¥;
 *   @arg       2, è¶…åŒºåŸŸäº†(å¤±è´¥);
 */
static uint8_t my_mem_free(uint8_t memx, uint32_t offset)
{
    int i;

    if (!mallco_dev.memrdy[memx])   /* æœªåˆå§‹åŒ–,å…ˆæ‰§è¡Œåˆå§‹åŒ– */
    {
        mallco_dev.init(memx);
        return 1;                   /* æœªåˆå§‹åŒ– */
    }

    if (offset < memsize[memx])     /* åç§»åœ¨å†…å­˜æ± å†…. */
    {
        int index = offset / memblksize[memx];      /* åç§»æ‰€åœ¨å†…å­˜å—å·ç  */
        int nmemb = mallco_dev.memmap[memx][index]; /* å†…å­˜å—æ•°é‡ */

        for (i = 0; i < nmemb; i++)                 /* å†…å­˜å—æ¸…é›¶ */
        {
            mallco_dev.memmap[memx][index + i] = 0;
        }

        return 0;
    }
    else
    {
        return 2;   /* åç§»è¶…åŒºäº†. */
    }
}

/**
 * @brief       é‡Šæ”¾å†…å­˜(å¤–éƒ¨è°ƒç”¨)
 * @param       memx : æ‰€å±å†…å­˜å—
 * @param       ptr  : å†…å­˜é¦–åœ°å€
 * @retval      æ— 
 */
void myfree(uint8_t memx, void *ptr)
{
    uint32_t offset;

    if (ptr == NULL) return;    /* åœ°å€ä¸º0. */

    offset = (uint32_t)ptr - (uint32_t)mallco_dev.membase[memx];
    my_mem_free(memx, offset);  /* é‡Šæ”¾å†…å­˜ */
}

/**
 * @brief       åˆ†é…å†…å­˜(å¤–éƒ¨è°ƒç”¨)
 * @param       memx : æ‰€å±å†…å­˜å—
 * @param       size : è¦åˆ†é…çš„å†…å­˜å¤§å°(å­—èŠ‚)
 * @retval      åˆ†é…åˆ°çš„å†…å­˜é¦–åœ°å€.
 */
void *mymalloc(uint8_t memx, uint32_t size)
{
    uint32_t offset;
    offset = my_mem_malloc(memx, size);

    if (offset == 0XFFFFFFFF)   /* ç”³è¯·å‡ºé”™ */
    {
        return NULL;            /* è¿”å›ç©º(0) */
    }
    else                        /* ç”³è¯·æ²¡é—®é¢˜, è¿”å›é¦–åœ°å€ */
    {
        return (void *)((uint32_t)mallco_dev.membase[memx] + offset);
    }
}

/**
 * @brief       é‡æ–°åˆ†é…å†…å­˜(å¤–éƒ¨è°ƒç”¨)
 * @param       memx : æ‰€å±å†…å­˜å—
 * @param       *ptr : æ—§å†…å­˜é¦–åœ°å€
 * @param       size : è¦åˆ†é…çš„å†…å­˜å¤§å°(å­—èŠ‚)
 * @retval      æ–°åˆ†é…åˆ°çš„å†…å­˜é¦–åœ°å€.
 */
void *myrealloc(uint8_t memx, void *ptr, uint32_t size)
{
    uint32_t offset;
    offset = my_mem_malloc(memx, size);

    if (offset == 0XFFFFFFFF)   /* ç”³è¯·å‡ºé”™ */
    {
        return NULL;            /* è¿”å›ç©º(0) */
    }
    else                        /* ç”³è¯·æ²¡é—®é¢˜, è¿”å›é¦–åœ°å€ */
    {
        my_mem_copy((void *)((uint32_t)mallco_dev.membase[memx] + offset), ptr, size);  /* æ‹·è´æ—§å†…å­˜å†…å®¹åˆ°æ–°å†…å­˜ */
        myfree(memx, ptr);      /* é‡Šæ”¾æ—§å†…å­˜ */
        return (void *)((uint32_t)mallco_dev.membase[memx] + offset);                   /* è¿”å›æ–°å†…å­˜é¦–åœ°å€ */
    }
}

```

```c
#include "main.h"
#include "bsp_init.h"
#include "malloc.h"
#include <stdio.h>

void SystemClock_Config(void);
void PeriphCommonClock_Config(void);
//static void MPU_Config(void);

const char *SRAM_NAME_BUF[SRAMBANK] = {"SRAMIN", "SRAM12", "SRAM4", "SRAMDTCM", "SRAMITCM"};


int main(void)
{
  //MPU_Config();
  HAL_Init();
  SystemClock_Config();
  PeriphCommonClock_Config();
  bsp_init();
  my_mem_init(SRAMIN);   /* åˆå§‹åŒ–å†…éƒ¨å†…å­˜æ± (AXI) */
  my_mem_init(SRAM12);   /* åˆå§‹åŒ–SRAM12å†…å­˜æ± (SRAM1+SRAM2) */
  my_mem_init(SRAM4);    /* åˆå§‹åŒ–SRAM4å†…å­˜æ± (SRAM4) */
  my_mem_init(SRAMDTCM); /* åˆå§‹åŒ–DTCMå†…å­˜æ± (DTCM) */
  my_mem_init(SRAMITCM); /* åˆå§‹åŒ–ITCMå†…å­˜æ± (ITCM) */
  while (1)
  {
  }
}


/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Supply configuration update enable
  */
  HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);

  /** Configure the main internal regulator output voltage
  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE0);

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_LSI
                              |RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.HSIState = RCC_HSI_DIV1;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 2;
  RCC_OscInitStruct.PLL.PLLN = 240;
  RCC_OscInitStruct.PLL.PLLP = 2;
  RCC_OscInitStruct.PLL.PLLQ = 2;
  RCC_OscInitStruct.PLL.PLLR = 2;
  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_2;
  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
  RCC_OscInitStruct.PLL.PLLFRACN = 0;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2
                              |RCC_CLOCKTYPE_D3PCLK1|RCC_CLOCKTYPE_D1PCLK1;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief Peripherals Common Clock Configuration
  * @retval None
  */
void PeriphCommonClock_Config(void)
{
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};

  /** Initializes the peripherals clock
  */
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_CKPER;
  PeriphClkInitStruct.CkperClockSelection = RCC_CLKPSOURCE_HSI;
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
  {
    Error_Handler();
  }
}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */


/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}
#ifdef USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */

```

## 3. å†…å­˜ç®¡ç†ç›¸å…³å‡½æ•°æ€»ç»“ï¼ˆHALåº“ï¼‰

### 3.1 MPUï¼ˆå†…å­˜ä¿æŠ¤å•å…ƒï¼‰ç›¸å…³å‡½æ•°

- **æ ¸å¿ƒé…ç½®æµç¨‹**ï¼ˆå››æ­¥å…³é”®æ“ä½œï¼‰ï¼š
  
  1. **ä½¿èƒ½MPUæ—¶é’Ÿ**ï¼ˆç³»ç»Ÿçº§ï¼‰
  2. **é…ç½®å†…å­˜åŒºåŸŸ**ï¼ˆåŸºåœ°å€/å¤§å°/å±æ€§ï¼‰
  3. **è®¾ç½®è®¿é—®æƒé™**ï¼ˆç”¨æˆ·/ç‰¹æƒæ¨¡å¼ï¼‰
  4. **å¯ç”¨MPU**

- `HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)`  
  **åŸºç¡€é…ç½®ç¤ºä¾‹**ï¼ˆä¿æŠ¤å…³é”®å†…å­˜åŒºåŸŸï¼‰ï¼š
  
  ```c
  MPU_Region_InitTypeDef mpu_init = {0};
  
  // é…ç½®ä¿æŠ¤åŒºåŸŸï¼ˆ0x20000000-0x20001FFFï¼Œ8KBï¼‰
  mpu_init.Enable = MPU_REGION_ENABLE;
  mpu_init.BaseAddress = 0x20000000;                    // åŸºåœ°å€
  mpu_init.Size = MPU_REGION_SIZE_8KB;                 // åŒºåŸŸå¤§å°
  mpu_init.AccessPermission = MPU_REGION_FULL_ACCESS;  // è®¿é—®æƒé™
  mpu_init.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;   // Bufferå±æ€§
  mpu_init.IsCacheable = MPU_ACCESS_CACHEABLE;         // Cacheå±æ€§
  mpu_init.IsShareable = MPU_ACCESS_NOT_SHAREABLE;     // å…±äº«å±æ€§
  mpu_init.Number = MPU_REGION_NUMBER0;                // åŒºåŸŸç¼–å·
  mpu_init.TypeExtField = MPU_TEX_LEVEL1;              // æ‰©å±•ç±»å‹
  mpu_init.SubRegionDisable = 0x00;                    // å­åŒºåŸŸç¦ç”¨
  mpu_init.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE; // æ‰§è¡Œæƒé™
  
  HAL_MPU_ConfigRegion(&mpu_init);
  HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);              // å¯ç”¨MPU
  ```

- **`MPU_Region_InitTypeDef` ç»“æ„ä½“æˆå‘˜è¯´æ˜**ï¼š
  
  | **æˆå‘˜**             | **è¯´æ˜** | **å…³é”®é€‰é¡¹**                              | **H750ç‰¹æ®Šè¯´æ˜** |
  | ------------------ | ------ | ------------------------------------- | ------------ |
  | `Enable`           | åŒºåŸŸä½¿èƒ½   | `MPU_REGION_ENABLE`, `DISABLE`        |              |
  | `BaseAddress`      | åŸºåœ°å€    | 32ä½åœ°å€                                 | å¿…é¡»å¯¹é½         |
  | `Size`             | åŒºåŸŸå¤§å°   | `32B`åˆ°`4GB`                           | æŒ‡æ•°å¯¹é½         |
  | `AccessPermission` | è®¿é—®æƒé™   | `NO_ACCESS`, `PRIV_RW`, `FULL_ACCESS` |              |
  | `DisableExec`      | æ‰§è¡Œæƒé™   | `ENABLE`, `DISABLE`                   | é˜²æ­¢ä»£ç æ³¨å…¥       |
  | `IsShareable`      | å…±äº«å±æ€§   | `ENABLE`, `DISABLE`                   | å¤šæ ¸åŒæ­¥         |
  | `Number`           | åŒºåŸŸç¼–å·   | `0-7`                                 | H750æ”¯æŒ8ä¸ªåŒºåŸŸ   |

- **å†…å­˜åŒºåŸŸå¤§å°å¯¹é½**ï¼š
  
  | **å¤§å°** | **å¯¹é½è¦æ±‚** | **BaseAddressè¦æ±‚** |
  | ------ | -------- | ----------------- |
  | 32B    | 32å­—èŠ‚     | bits[4:0] = 0     |
  | 64B    | 64å­—èŠ‚     | bits[5:0] = 0     |
  | 1KB    | 1KB      | bits[9:0] = 0     |
  | 8KB    | 8KB      | bits[12:0] = 0    |
  | 1MB    | 1MB      | bits[19:0] = 0    |
  | 4GB    | 4GB      | 0x00000000        |

- **è®¿é—®æƒé™é…ç½®**ï¼š
  
  | **å®å®šä¹‰**                  | **ç‰¹æƒæ¨¡å¼** | **ç”¨æˆ·æ¨¡å¼** | **åº”ç”¨åœºæ™¯** |
  | ------------------------ | -------- | -------- | -------- |
  | `MPU_REGION_NO_ACCESS`   | æ— è®¿é—®      | æ— è®¿é—®      | ä¿æŠ¤å…³é”®å†…å­˜   |
  | `MPU_REGION_PRIV_RW`     | è¯»å†™       | æ— è®¿é—®      | å†…æ ¸æ•°æ®     |
  | `MPU_REGION_PRIV_RW_URO` | è¯»å†™       | åªè¯»       | é…ç½®å‚æ•°     |
  | `MPU_REGION_FULL_ACCESS` | è¯»å†™       | è¯»å†™       | é€šç”¨å†…å­˜     |

### 3.2 Cacheç®¡ç†å‡½æ•°

- **æŒ‡ä»¤Cacheï¼ˆI-Cacheï¼‰**ï¼š
  
  ```c
  // ä½¿èƒ½I-Cache
  HAL_ICACHE_Enable();
  
  // ç¦ç”¨I-Cache
  HAL_ICACHE_Disable();
  
  // æ¸…é™¤I-Cache
  HAL_ICACHE_Invalidate();
  
  // é…ç½®ç¼“å­˜è¡Œå¤§å°
  HAL_ICACHE_SetConfigLineSize(ICACHE_1WAY);
  ```

- **æ•°æ®Cacheï¼ˆD-Cacheï¼‰**ï¼š
  
  | **å‡½æ•°**                         | **åŸå‹** | **ç‰¹ç‚¹**    | **åº”ç”¨åœºæ™¯** |
  | ------------------------------ | ------ | --------- | -------- |
  | `HAL_DCACHE_Enable()`          | `void` | å¯ç”¨D-Cache | æé«˜æ€§èƒ½     |
  | `HAL_DCACHE_Disable()`         | `void` | ç¦ç”¨D-Cache | è°ƒè¯•       |
  | `HAL_DCACHE_Clean()`           | `void` | æ¸…ç†è„æ•°æ®     | DMAå‰     |
  | `HAL_DCACHE_Invalidate()`      | `void` | ä½¿æ— æ•ˆ       | DMAå     |
  | `HAL_DCACHE_CleanInvalidate()` | `void` | æ¸…ç†å¹¶æ— æ•ˆ     |          |
  | `HAL_DCACHE_GetStatus()`       | `void` | è·å–çŠ¶æ€      |          |

- **Cacheè¡Œæ“ä½œ**ï¼ˆé«˜çº§åŠŸèƒ½ï¼‰ï¼š
  
  ```c
  // æŒ‰åœ°å€æ¸…ç†Cache
  HAL_DCACHE_CleanByAddr((uint32_t*)buffer, size);
  
  // æŒ‰åœ°å€ä½¿æ— æ•ˆ
  HAL_DCACHE_InvalidateByAddr((uint32_t*)buffer, size);
  
  // æ¸…ç†å¹¶ä½¿æ— æ•ˆ
  HAL_DCACHE_CleanInvalidateByAddr((uint32_t*)buffer, size);
  ```

- **Cacheé…ç½®ç¤ºä¾‹**ï¼š
  
  ```c
  // åˆå§‹åŒ–Cache
  void Cache_Init(void)
  {
      // ä½¿èƒ½I-Cacheå’ŒD-Cache
      HAL_ICACHE_Enable();
      HAL_DCACHE_Enable();
  
      // é…ç½®é¢„å–
      __HAL_SYSCFG_ENABLE_ITCM();      // å¯ç”¨ITCM
      __HAL_SYSCFG_ENABLE_DTCM();      // å¯ç”¨DTCM
      __HAL_SYSCFG_EnableBusL2flitf(); // å¯ç”¨L2FLITF
  }
  ```

### 3.3 å†…å­˜å±éšœä¸åŒæ­¥

- **å†…å­˜å±éšœå‡½æ•°**ï¼š
  
  ```c
  // æ•°æ®å†…å­˜å±éšœï¼ˆDMBï¼‰
  __DMB();
  
  // æ•°æ®åŒæ­¥å±éšœï¼ˆDSBï¼‰
  __DSB();
  
  // æŒ‡ä»¤åŒæ­¥å±éšœï¼ˆISBï¼‰
  __ISB();
  ```
  
  **åº”ç”¨åœºæ™¯**ï¼š

```c
 // åœ¨ä¿®æ”¹å‘é‡è¡¨å
SCB->VTOR = new_vector_table;
__DSB();  // ç¡®ä¿ä¿®æ”¹å®Œæˆ
__ISB();  // æ¸…é™¤æµæ°´çº¿

// åœ¨DMAä¼ è¾“å‰
HAL_DCACHE_CleanByAddr(buffer, size);
__DSB();  // ç¡®ä¿Cacheæ¸…ç†å®Œæˆ
```

- **åŸå­æ“ä½œæ”¯æŒ**ï¼š
  
  ```c
  // åŸå­é€’å¢
  uint32_t __sync_fetch_and_add(volatile uint32_t *ptr, uint32_t value);
  
  // åŸå­æ¯”è¾ƒäº¤æ¢
  uint32_t __sync_val_compare_and_swap(volatile uint32_t *ptr, uint32_t old, uint32_t new);
  ```

### 3.4 TCMï¼ˆç´§å¯†è€¦åˆå†…å­˜ï¼‰ç®¡ç†

- **ITCMï¼ˆæŒ‡ä»¤TCMï¼‰**ï¼š
  
  ```c
  // ä½¿èƒ½ITCM
  __HAL_SYSCFG_ENABLE_ITCM();
  
  // ç¦ç”¨ITCM
  __HAL_SYSCFG_DISABLE_ITCM();
  ```
  
  **é“¾æ¥è„šæœ¬é…ç½®**ï¼ˆ.ldæ–‡ä»¶ï¼‰ï¼š

```c
  ITCM (rwx) : ORIGIN = 0x00000000, LENGTH = 16K
SECTIONS
{
    .itcm_text : 
    {
        *(.itcm_text)
    } > ITCM
}
```

  **ä»£ç æ”¾ç½®**ï¼š

```c
  __attribute__((section(".itcm_text")))
void Fast_Function(void)
{
    // æ”¾ç½®åœ¨ITCMä¸­æ‰§è¡Œ
}
```

- **DTCMï¼ˆæ•°æ®TCMï¼‰**ï¼š
  
  ```c
  // ä½¿èƒ½DTCM
  __HAL_SYSCFG_ENABLE_DTCM();
  
  // ç¦ç”¨DTCM
  __HAL_SYSCFG_DISABLE_DTCM();
  ```
  
  **é“¾æ¥è„šæœ¬é…ç½®**ï¼š

```c
  DTCM (rw) : ORIGIN = 0x20000000, LENGTH = 64K
SECTIONS
{
    .dtcm_data : 
    {
        *(.dtcm_data)
    } > DTCM
}
```

  **æ•°æ®æ”¾ç½®**ï¼š

```c
  __attribute__((section(".dtcm_data")))
uint32_t critical_buffer[1024];
```

### 3.5 ä½¿ç”¨ç¤ºä¾‹ï¼ˆå®Œæ•´æµç¨‹ï¼‰

#### 3.5.1 ç¤ºä¾‹1ï¼šMPUä¿æŠ¤å…³é”®å†…å­˜åŒºåŸŸ

```c
// 1. é…ç½®MPUä¿æŠ¤å†…æ ¸å†…å­˜ï¼ˆ0x20000000-0x2000FFFFï¼Œ64KBï¼‰
void Configure_MPU_Protection(void)
{
    MPU_Region_InitTypeDef mpu_init = {0};

    // ç¦ç”¨MPUè¿›è¡Œé…ç½®
    HAL_MPU_Disable();

    // é…ç½®ä¿æŠ¤åŒºåŸŸ
    mpu_init.Enable = MPU_REGION_ENABLE;
    mpu_init.Number = MPU_REGION_NUMBER0;
    mpu_init.BaseAddress = 0x20000000;
    mpu_init.Size = MPU_REGION_SIZE_64KB;
    mpu_init.AccessPermission = MPU_REGION_PRIV_RW;     // ç‰¹æƒçº§è¯»å†™
    mpu_init.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE; // å¯æ‰§è¡Œ
    mpu_init.IsShareable = MPU_ACCESS_NOT_SHAREABLE;
    mpu_init.IsCacheable = MPU_ACCESS_CACHEABLE;
    mpu_init.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
    mpu_init.SubRegionDisable = 0x00;

    HAL_MPU_ConfigRegion(&mpu_init);

    // é…ç½®å¤–è®¾å†…å­˜åŒºåŸŸï¼ˆä¸ç¼“å­˜ï¼‰
    mpu_init.Number = MPU_REGION_NUMBER1;
    mpu_init.BaseAddress = 0x40000000;
    mpu_init.Size = MPU_REGION_SIZE_512MB;
    mpu_init.AccessPermission = MPU_REGION_FULL_ACCESS;
    mpu_init.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
    mpu_init.IsBufferable = MPU_ACCESS_BUFFERABLE;
    HAL_MPU_ConfigRegion(&mpu_init);

    // å¯ç”¨MPU
    HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
}

// 2. MPUå¼‚å¸¸å¤„ç†
void MemManage_Handler(void)
{
    // MPUè®¿é—®è¿è§„å¤„ç†
    if (SCB->CFSR & SCB_CFSR_MEMFAULTSR_Msk) {
        // è¯»å–æ•…éšœåœ°å€
        uint32_t fault_addr = SCB->MMFAR;

        // è®°å½•æ•…éšœ
        log_memory_fault(fault_addr);

        // ç³»ç»Ÿå¤ä½æˆ–å®‰å…¨å…³æœº
        NVIC_SystemReset();
    }
}
```

#### 3.5.2 ç¤ºä¾‹2ï¼šCacheä¸DMAååŒå·¥ä½œ

```c
#define DMA_BUFFER_SIZE  1024
__attribute__((section(".dma_buffer"))) uint8_t dma_rx_buffer[DMA_BUFFER_SIZE];

// 1. DMAæ¥æ”¶å®Œæˆå›è°ƒ
void HAL_DMA_RxCpltCallback(DMA_HandleTypeDef *hdma)
{
    if (hdma == &hdma_usart1_rx) {
        // DMAæ¥æ”¶å®Œæˆ
        // å¿…é¡»ä½¿D-Cacheæ— æ•ˆï¼Œç¡®ä¿è¯»å–æœ€æ–°æ•°æ®
        HAL_DCACHE_InvalidateByAddr((uint32_t*)dma_rx_buffer, DMA_BUFFER_SIZE);

        // å¤„ç†æ¥æ”¶åˆ°çš„æ•°æ®
        Process_UART_Data(dma_rx_buffer, DMA_BUFFER_SIZE);

        // é‡æ–°å¯åŠ¨DMA
        HAL_DMA_Start_IT(&hdma_usart1_rx, 
                        (uint32_t)&USART1->RDR,
                        (uint32_t)dma_rx_buffer,
                        DMA_BUFFER_SIZE);
    }
}

// 2. å‘é€æ•°æ®ï¼ˆDMAå‰æ¸…ç†Cacheï¼‰
void Send_UART_Data(uint8_t *data, uint16_t size)
{
    // ç¡®ä¿æ•°æ®åœ¨å†…å­˜ä¸­æ˜¯æœ€æ–°çš„
    HAL_DCACHE_CleanByAddr((uint32_t*)data, size);

    // å¯åŠ¨DMAå‘é€
    HAL_DMA_Start(&hdma_usart1_tx, 
                  (uint32_t)data,
                  (uint32_t)&USART1->TDR,
                  size);
}

// 3. åˆå§‹åŒ–å‡½æ•°
void Memory_System_Init(void)
{
    // ä½¿èƒ½Cache
    HAL_ICACHE_Enable();
    HAL_DCACHE_Enable();

    // é…ç½®TCM
    __HAL_SYSCFG_ENABLE_ITCM();
    __HAL_SYSCFG_ENABLE_DTCM();

    // MPUé…ç½®
    Configure_MPU_Protection();
}
```

## 4. å…³é”®æ³¨æ„äº‹é¡¹

1. **MPUé…ç½®é™·é˜±**ï¼š
   
   - **å¿…é¡»å…ˆç¦ç”¨MPU**å†è¿›è¡Œé…ç½®
     
     ```c
     HAL_MPU_Disable();
     HAL_MPU_ConfigRegion(&mpu_init);
     HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
     ```
   
   - **åŒºåŸŸé‡å **ï¼šåé…ç½®çš„åŒºåŸŸä¼˜å…ˆçº§é«˜
   
   - **é»˜è®¤å†…å­˜æ˜ å°„**ï¼š
     
     - CodeåŒºåŸŸï¼š`0x00000000-0x1FFFFFFF`
     - SRAMåŒºåŸŸï¼š`0x20000000-0x3FFFFFFF`

2. **Cacheä¸€è‡´æ€§**ï¼š
   
   | **åœºæ™¯**    | **Cacheæ“ä½œ**  | **åŸå› **      |
   | --------- | ------------ | ----------- |
   | DMAå†™å†…å­˜    | `Invalidate` | ç¡®ä¿CPUè¯»å–æœ€æ–°æ•°æ® |
   | DMAè¯»å†…å­˜    | `Clean`      | ç¡®ä¿DMAè¯»å–æœ€æ–°æ•°æ® |
   | å¤–éƒ¨ä¿®æ”¹å†…å­˜    | `Invalidate` |             |
   | CPUå†™åDMAè¯» | `Clean`      |             |

3. **TCMä½¿ç”¨è¦ç‚¹**ï¼š
   
   - **ITCM**ï¼šæ”¾ç½®å…³é”®ä¸­æ–­æœåŠ¡ç¨‹åº
   - **DTCM**ï¼šæ”¾ç½®å®æ—¶æ•°æ®ç¼“å†²åŒº
   - **å¤§å°æœ‰é™**ï¼šH750é€šå¸¸16KB ITCM + 64KB DTCM
   - **é›¶ç­‰å¾…è®¿é—®**ï¼šæ¯”æ™®é€šSRAMæ›´å¿«

4. **å†…å­˜å±éšœåº”ç”¨**ï¼š
   
   ```c
   // åœ¨ä¿®æ”¹é¡µè¡¨å
   Update_Page_Table();
   __DSB();
   __ISB();
   
   // åœ¨å¤šæ ¸é€šä¿¡ä¸­
   shared_flag = 1;
   __DMB();  // ç¡®ä¿å…¶ä»–æ ¸å¿ƒèƒ½çœ‹åˆ°æ›´æ–°
   ```

5. **æ€§èƒ½ä¼˜åŒ–æŠ€å·§**ï¼š
   
   - **å…³é”®ä»£ç æ”¾ITCM**ï¼š
     
     ```c
     __attribute__((section(".itcm_text"), optimize("O3")))
     void RealTime_Control(void) {
         // å®æ—¶æ§åˆ¶ç®—æ³•
     }
     ```
   
   - **é¢‘ç¹è®¿é—®æ•°æ®æ”¾DTCM**ï¼š
     
     ```c
     __attribute__((section(".dtcm_data")))
     PID_Controller_TypeDef pid_motor;
     ```
   
   - **DMAç¼“å†²åŒºéç¼“å­˜**ï¼š
     
     ```c
     
     ```

---

### 4.1 H750ç‰¹æœ‰ä¼˜åŒ–æŠ€å·§

| **åœºæ™¯**    | **è§£å†³æ–¹æ¡ˆ**  | **æ€§èƒ½æå‡** | **å®ç°è¦ç‚¹**         |
| --------- | --------- | -------- | ---------------- |
| **å®æ—¶æ€§ä¿è¯** | ITCM+DTCM | å»¶è¿Ÿâ†“90%   | å…³é”®ä»£ç /æ•°æ®æ”¾ç½®        |
| **é«˜é€ŸDMA** | Cacheç®¡ç†   | æ•°æ®ä¸€è‡´æ€§    | Clean/Invalidate |
| **å®‰å…¨ç³»ç»Ÿ**  | MPUä¿æŠ¤     | é˜²æ­¢è¶Šç•Œè®¿é—®   | å†…æ ¸å†…å­˜éš”ç¦»           |
| **å¤šæ ¸åŒæ­¥**  | å†…å­˜å±éšœ      | ä¸€è‡´æ€§ä¿è¯    | DMB/DSB/ISB      |

> **é¿å‘æŒ‡å—**ï¼š
> 
> 1. **H750 Cacheæ¶æ„**ï¼š
>    
>    - æ”¯æŒI-Cacheå’ŒD-Cache
>    - Cacheè¡Œå¤§å°é€šå¸¸64å­—èŠ‚
>    - ä½¿ç”¨`ByAddr`å‡½æ•°æ—¶åœ°å€å¿…é¡»Cacheè¡Œå¯¹é½
> 
> 2. **MPUåŒºåŸŸé™åˆ¶**ï¼š
>    
>    - H750é€šå¸¸æ”¯æŒ8ä¸ªMPUåŒºåŸŸ
>    - åˆç†è§„åˆ’åŒºåŸŸç”¨é€”
>    - å¯ä»¥ç”¨ä¸€ä¸ªå¤§åŒºåŸŸåŠ å­åŒºåŸŸç¦ç”¨
> 
> 3. **é“¾æ¥è„šæœ¬é…ç½®**ï¼š
>    
>    - æ­£ç¡®é…ç½®TCMå’Œæ™®é€šå†…å­˜åŒºåŸŸ
>    - é¿å…å†…å­˜åŒºåŸŸé‡å 
> 
> 4. **è°ƒè¯•æ¨¡å¼**ï¼š
>    
>    - è°ƒè¯•æ—¶å¯ä¸´æ—¶ç¦ç”¨MPUå’ŒCache
>    - ä½†æœ€ç»ˆäº§å“å¿…é¡»å¯ç”¨ä»¥ä¿è¯æ€§èƒ½å’Œå®‰å…¨

---

### 4.2 å†…å­˜ç®¡ç†æ€§èƒ½å¯¹æ¯”

| **å†…å­˜ç±»å‹** | **è®¿é—®é€Ÿåº¦** | **ç‰¹ç‚¹**  | **é€‚ç”¨åœºæ™¯** |
| -------- | -------- | ------- | -------- |
| ITCM     | 1å‘¨æœŸ      | é›¶ç­‰å¾…     | å…³é”®ä»£ç      |
| DTCM     | 1å‘¨æœŸ      | é›¶ç­‰å¾…     | å®æ—¶æ•°æ®     |
| SRAM     | 1-2å‘¨æœŸ    | å¯Cache  | é€šç”¨æ•°æ®     |
| Flash    | 2-3å‘¨æœŸ    | å¯Cache  | ä»£ç å­˜å‚¨     |
| å¤–éƒ¨SDRAM  | 10+å‘¨æœŸ    | å¿…é¡»Cache | å¤§å®¹é‡å­˜å‚¨    |

> **é‡è¦æç¤º**ï¼š
> 
> - MPUæ˜¯**ç³»ç»Ÿå®‰å…¨çš„åŸºçŸ³**ï¼Œå¯é˜²æ­¢å†…å­˜è¶Šç•Œè®¿é—®
> - Cacheç®¡ç†æ˜¯**DMAåº”ç”¨çš„å…³é”®**ï¼Œç¡®ä¿æ•°æ®ä¸€è‡´æ€§
> - TCMæä¾›**ç¡®å®šæ€§è®¿é—®æ—¶é—´**ï¼Œé€‚åˆå®æ—¶ç³»ç»Ÿ
> - å†…å­˜å±éšœä¿è¯**å†…å­˜æ“ä½œé¡ºåº**ï¼Œåœ¨å…³é”®åŒæ­¥ç‚¹ä½¿ç”¨

---
